- [x] File文件类有哪些API?
      getName()
      getPath()
      getParent()
      isFile()
      isDirectory()
- [x] transient和static修饰的成员变量不序列化
      transient 修饰是临时变量, 临时变量不应该序列化
      static 修饰的是静态变量, 不属于某个对象, 所以不应序列化到某个对象中
- [x] TCP三次握手,四次挥手 #三次握手 #四次挥手 
      三次握手:
	      - 第一次: 客户端向服务端发送连接请求
	      - 第二次: 服务端收到客户端的请求后, 响应一个确认信息, 表示服务端能收到客户端的信息.
	      - 第三次: 客户端收到服务端的确认信息后向服务端再发送一个确认信息, 表示客观上服务端和客户端都可以收发信息, 成功建立起了连接
      四次挥手
       - 第一次: 客户端向服务端发送结束请求报文, 表示不在发送信息给服务端
       - 第二次: 服务端收到请求后向客户端发送一个确认信息, 代表服务端知道客户端不再发信息了
       - 第三次: 隔一段时间后, 服务端向客户端再次发送一个确认信息, 除了序号不同,其它都相同, 代表服务端接收完毕
       - 第四次: 客户端收到服务器的两次确认信息后, 对第二次确认信息响应确认收到,正式断开连接

- [x] 类加载器有几种,分别是什么
     四种 
			- 引导类加载器
      - 扩展类加载器
      - 应用程序类加载器
      - 自定义类加载器
        tomcat服务器就是自定义类加载器, 应为tomcat服务器上可能部署多个web项目, 多个项目可能用到了一些相同的类, 它们的包名类名都相同, 但是版本号可能不同, 所以需要单独加载
- [x] 类加载器加载过程,双亲委派制
      - 应用程序类加载器接到加载任务,首先不自己加载,它有个parent成员变量记录了扩展类加载器, 将加载任务委托给扩展类加载器;
      - 扩展类加载器接到加载任务也不进行加载, 而是委托给引导类加载器;
      - 引导类加载器接到加载任务, 首先查看JVM中是否加载过该类, 如果加载过直接返回, 如果没加载过,尝试进行加载,如果可以加载,就加载并返回, 如果无法加载, 就将加载任务回传给扩展类加载器;
      - 扩展类加载器接到回传过来的加载任务,首先看JVM中是否加载过这个类, 如果加载过, 就直接返回, 如果没加载过, 就尝试进行加载, 如果可以加载,就加载并返回, 如果无法加载, 就将加载任务回传给应用程序类加载器;
      - 应用程序类加载器接到回传过来的加载任务, 首先看JVM中是否加载过这个类, 如果加载过就直接返回, 如果没有加载过,就尝试进行加载, 如果可以成功加载, 就加载并返回, 如果不能成功加载, 就报异常: 类找不到异常ClassNotFoundException
- [x] 反射的四个作用
      1. 动态创建任意类的对象
      2. 动态获取任意类的任何信息
      3. 动态修改任意类的静态成员变量和任意对象的实例变量 
      4. 动态调用任意类的静态成员方法和任意类的实例方法
- [x] 反射修改任意对象的实例变量,到底修改的是哪个对象的
      修改的是该类型所有对象的
- [x] 反射可以获取某个类创建了哪些该类型的对象吗
      不可以, 但可以修改该类所有实例的私有属性值, 如果要针对某个对象进行修改, 则直接根据这个对象修改即可, 无需用到反射



- [ ] MySql的约束有几种
- [ ] 事务的隔离级别
- [ ] 事务的四大特性
- [ ] Spring如何管理事务的
- [ ] 事务的传播行为
- [ ] Spring事务失效的几种情况
- [ ] SpringBoot怎么开启事务管理器
- [ ] ThreadLocal





