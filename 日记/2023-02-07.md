- [x] MySql的约束有几种
      主键约束 primary key
      唯一约束 unique
      非空约束 not null
      自增约束 auto_increment
- [x] 事务的隔离级别
      读未提交 脏读 不可重复读 幻读
      读已提交 不可重复读 幻读
      可重复读 幻读
      串行化
- [x] 事务的四大特性
      原子性
      一致性
      隔离性
      持久性
- [x] Spring如何管理事务的
      编程式事务 
	      TransactioinManager或者TransactionTemplate 手动管理事务
      声明式事务 
	      @Transactional注解 自动管理事务
- [x] 事务的传播行为
      有7种,常用的有3种
      required(默认) : 原先有事务,则使用原先的事务,否则新建一个事务
      required_new : 不论原先有没有事务, 都新开启一个事务, 如果原先有事务则将原先的事务挂起
      support: 原先有事务, 则使用原先的事务, 否则不使用事务
     -------------------
      不常用的: 
      not support: 原先无论有没有事务,都不使用事务
      mandatory 还有一个是原先有事务就用,原先没有就报错
      never 如果原先有事务,就报错
      nested 还有一个是原先有事务, 则嵌在当前事务内执行, 原先没有事务, 就新建一个事务
- [x] Spring事务失效的几种情况
      1. 方法不是public修饰的
      2. 类内的其它没有事务的方法调用有事务的方法
      3. catch捕获到了不该捕获到的异常, 导致无法正常回滚,导致事务失效
      4. rollbackfor 指定了不该捕获的异常, 导致事务无法正常提交, 导致事务失效, 提交前会检查rollback是不是=true
      5. 没有交给spring托管, 对象没有装配到容器中
      6. 没开启事务管理器, 开启事务管理器需要在配置类上添加@EnableTransactionManager注解
      7. 事务的传播行为设置有误, 比如not_spport
      8. 数据源不支持事务, mysql的MyISAM引擎不支持事务
- [x] SpringBoot怎么开启事务管理器
      在配置类上添加@EnableTransactionManager
- [x] ThreadLocal
      确保线程资源独立性, 底层是键值对,
      key为当前线程对象, value为要存储的数据,这样就线程只能取到自己线程对应的数据,保证了资源的独立性
- [x] REST风格的请求是怎么实现的
      1. 前端请求时候要用post请求, 需要用隐藏标签传过来一个name为`_method`的参数, value为DELETE 或者 PUT
      2. 有一个HiddenHttpRequestFilter过滤器, 会取出来这个参数, 
         将这个参数的值查看是否存在一个请求方式的常量列表, 
         不存在则不处理, 
         存在则将值设置为大写, 然后根据值,调用对应的doDelete()方法, 或者 doPut()方法,来处理delete请求或者put请求
- [x] 消息转换器是说什么
      消息转换器说的是将Java对象和前端传过来的请求参数进行相互转换
      就是两个注解 @RequestBody 和 @ResponsBody
      @RequestBody加到参数前面, 可以将请求参数封装到实体类中接收
      @ResponsBody加到方法前面或者类前面, 可以将响应数据转换为Json串格式响应给前端
- [x] 拦截器与过滤器的区别
      过滤器: 
	      web组件, servlet容器创建,对servlet进行过滤
	      两个触发时机: 
		      servlet执行前
		      servlet执行后
      拦截器:
	     是继承在框架里的, 对controller进行过滤,
	     三个触发时机: 
		     controller执行前
		     controller执行后
		     数据响应给前端之前
- [ ] 拦截器的实现方法
      写一个配置类, 实现 HandlerInterceptor 接口
      重写三个方法: 
	      - preHandle()
	      - postHandle()
	      - afterCompletion()
- [ ] 该看拦截器的工作原理
 - 单个拦截器
	-   浏览器向服务器发送请求[URL匹配]
	-   执行拦截器第一个方法preHandle()
	-   执行Controller中相应方法,处理请求,做出相应
	-   执行拦截器第二个方法postHandle()
	-   ViewResolver&View执行,视图渲染
	-   最后执行拦截器第三方法afterCompletion()
	-   响应
 - 多个拦截器
	-   浏览器向服务器发送请求[URL匹配]
	-   执行**拦截器1**第一个方法**preHandle**()
	-   执行**拦截器2**第一个方法**preHandle**()
	-   执行Controller中相应方法,处理请求,做出相应
	-   执行**拦截器2**第二个方法**postHandle**()
	-   执行**拦截器1**第二个方法**postHandle**()
	-   ViewResolver&View执行,视图渲染
	-   最后执行**拦截器2**第三方法**afterCompletion**()
	-   最后执行**拦截器1**第三方法**afterCompletion**()
	-   响应




- [ ] 本地锁有哪些 有啥区别 有什么局限性?
- [ ] HashTable和ConcurrentHashMap的区别?
- [ ] RabbitMQ如何保证消息不丢失?
- [ ] redis和mysql一致性问题?redis延迟双删,500ms怎么确定的,作用是什么?
- [ ] 线程池有几种?你用的哪一种? 固定长度还是可变长度?
- newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
- newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
- newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。
- newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
原文链接： https://blog.csdn.net/weixin_59714026/article/details/124652048
- [ ] 分布式事务怎么做的? RabbitMQ如何百分百投递成功? 如果出现异常, 补偿机制是什么? 死信队列中的消息怎么处理?
- [ ] 