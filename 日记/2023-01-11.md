## 面试题:
#### this和super的底层实现原理?
this的底层实现是默认传值 , super是靠INVOKESPECIAL指令.
this: 我们创建一个对象时,实例化过程中会生成一个this指针和一个super指针,在用这个对象调用实例方法的时候,编译器会在我们的参数列表最前面加上当前对象,然后实例方法的形参列表最前面默认是有一个当前类型的this对象,然后就可以接收到传过去的对象,所以this就指向了当前对象,可以用this来调用其它的实例方法.
supper: 我们创建一个对象时, 初始化时会有一个INVOKESPECIAL指令,这个指令时用来调用一些需要特殊处理的实例方法,包括实例初始化方法,私有方法和父类方法, super就是通过INVOKESPECEAL指令调用父类方法的.
参考原文: http://t.csdn.cn/eCLYO

#### 什么是高内聚低耦合?
低耦合就是模块之间的依赖要尽可能降低,每个模块作能够独立的完成一项任务,而不依赖其它模块,就是即使其它模块出现问题,也尽量不影响到当前模块的运行.高内聚就是模块内部的一个一个的类, 一个一个的方法,他们应该全部都为这个模块的总的功能而服务,应该将每一个方法的任务尽可能的细分,这样的话,当模块出现问题,我们能快速精确的定位到是哪个方法出现问题,只需要修改这个方法而不需要变动其它的方法.其实我们在实现低耦合,也就是尽可能降低模块间依赖的过程中也就无意间实现了高内聚,每个任务都被细致的划分到了每个模块,模块内部也就只会为了这一个任务而服务了. 所需要的参数和返回值都是清晰可见的,也就达到了易于开发和维护的目的.
参考原文:http://t.csdn.cn/TMh4S


#### 如何解决float和double精度损失问题？
可以使用BigDesimal, BigDesimal可以存储任意大小的数字，但是要注意创建BigDesimal对象时一定要传入一个字符串类型的数字“0.1”，而不是float类型的数字0.1,因为这个float类型或者double类型的0.1本身就是不精确的，它可能是：0.1000000000000000055511151231257827021181583404541015625

#### 常见的编译时异常和运行时异常
编译时：文件找不到异常，类找不到异常，输入输出流异常，数据库操作异常（SQL异常），
运行时异常： 空指针异常，类型转换异常，内存溢出异常（OOM、SOF），算数异常，数组下标越界，参数不合法异常，

#### 线程池的拒绝策略（4种）？
阻塞队列已经满了，然后已开线程数达到最大线程数，则触发拒绝策略
1. 直接抛异常（默认）
2. 直接抛弃不处理
3. 将阻塞队列中的第一个弹出去（等待最久的抛弃），新来的排到最后
4. 哪个线程来请求，就让这个线程去处理（谁让我做事，我就让他自己做）
参考链接：http://t.csdn.cn/3rOG5

#### redis 的内存淘汰策略（驱逐策略）(8种)？
内存满了
1. 不驱逐，直接抛异常
2. 最短时间者驱逐（ttl剩余最小）
3. 设置了ttl的key中随机驱逐一个
4. 所有key中随机驱逐一个
5. 设置了ttl的key中丢弃最近最少使用者驱逐
6. 所有key中最近最少使用者驱逐
7. 设置了ttl的key中使用频率最小的驱逐
8. 所有的key中使用过频率最少的驱逐
参考链接：http://cd.itheima.com/news/20220801/181457.html


#### ArrayList 和 Vector 的区别？
ArrayList： 
	线程不安全的动态数组，数组初始化长度为 0，第一次添加的时候设置容量大小为10(懒加载思想，节约内存)，默认扩容为 1.5 倍。 
Vector： 
	线程安全的动态数组，数组初始化长度为 10，默认扩容为 2 倍。

#### ArrayList扩容？
无参初始化时，默认是空数组，第一次添加时，如果添加的个数小于10，设置容量为10，否则设置为需要的数量。当需要扩容时，会扩容到1.5倍，底层使用旧的容量右移一位然后加上旧的容量，其实就是1.5倍，扩容到1.5倍如果小于所需要的最小容量，就扩容为所需要的最小容量，如果大于Integer的最大值，就扩容为Integer的最大值。
参考链接：http://t.csdn.cn/Z8cbG