# 自我介绍

我叫张庆杰，今年23岁，毕业于山西大同大学计算机科学与技术专业，从事Java开发两年 , 拥有良好的编程习惯, 熟练使用 SpringBoot+SpringCloud 进行微服务开发, 也掌握了RabbitMQ,Redis,docker等技术,  
最近写的项目是蓝云购,它 是一个 B2C 模式的玻璃制品在线销售平台

在网上看到了贵公司的招聘信息, 觉得自己各方面条件都比较符合, 所以就投出了简历.

我的介绍就到这里, 谢谢

我能问你一些问题吗
公司里面Java这块用的技术栈是什么?
公司里面前后端的人员是怎么分配的, 各有多少人?后端这块在招的是几个人?
工作时间是怎样的 ,周六日是双休吗?
晚上加班或者周末加班 都有没有加班费?
有没有一些补贴?



# 上一家公司情况


北京煜明嘉景科技发展有限公司
北京市房山区阎富路69号院15号楼-1至4层101三层02

山西思亿欧网络科技有限公司
山西综改示范区
太原学府园区晋阳街202号英语周报大厦1516室

山西省人民医院
三级甲等 综合医院 公立
医院地址：山西省太原市迎泽区双塔寺东街26号




# 集合

Collection

-   List
    
    -   ArrayList
        
    -   Vector
        
    -   LinkedList
        
-   Set
    
    -   HashSet
        
        -   LinkedHashSet
            
    -   TreeSet Map
        
-   Hashtable
    
    -   Properties
        
-   HashMap
    
    -   LinkedHashMap
        
-   TreeMap
    

# 接口响应过慢排查原因

-   是不是接口设计的业务太多，导致程序执行很久
    
-   也可能是sql层面的问题
    
-   也可能是代码编写问题，重复循环读取
    

# IO流

-   FileInputStream ，适用于任意类型文件读写
    
-   FileOutputStram
    
-   FileReader ，只能用于纯文本文件的读和写，而且还要求文件的编码和程序的编码一致。
    
-   FileWriter 纯文本文件： .txt,.java,.css,.js, .md, .html等 不是纯文本文件： .word, .ppt, .xls, .jpg, .avi, ...
    

# MySQL

## MySQL事务

-   事务特性 ACID
    
-   事务并发读问题
    
-   事务隔离级别
    
-   事务的传播行为 propagation behavior
    

## 本地事务

单个服务访问同一个数据库

## 分布式事务

-   操作的是不同数据库
    
-   为了保证不同数据库之间数据的一致性
    

## 分布式事务的解决方案

[[卡片盒/分布式事务]]

-   基于XA协议的两阶段提交(2PC)(低效率)
    
    -   投票阶段
        
    -   提交阶段
        
-   代码补偿事务(TCC两阶段提交）
    
    -   最短预留时间
        
-   本地消息表（异步确保）- 事务最终一致性 (MQ + Table)
    
-   事务消息(RoketMQ)
    
    -   半消息+消息回查
        
-   Seata
    

项目中，我们采用的是RabbitMQ，来解决的分布式事务问题

## MySQL索引优化

**使用Explain+sql 对sql进行性能分析** 会关注几个字段，像 type 、possible_key 、key 、key_len 、Extra ，来检查索引的使用情况，是否充分使用了索引，以及对sql的访问类型 （system > const > eq_ref > ref > range > index > ALL）

**避免造成索引失效**

-   计算、函数导致索引失效
    
-   Like以%开头索引失效，页面搜索严禁左模糊或者全模糊
    
-   不等于(!= 或者<>)索引失效
    
-   IS NOT NULL
    
-   类型转换导致索引失效
    
-   全职匹配我最爱，创建联合索引效率最高
    
-   如果索引了多列，要遵守最左前缀法则，即查询从`索引的最左前列`开始并且不跳过索引中的列。
    
-   索引中范围条件右边的列失效
    

**关联查询优化**

-   左外连接，student left join score
    
    -   student 是驱动表
        
    -   score 是被驱动表
        
    -   在被驱动表上创建索引，可以避免全表扫描
        
    -   同时在两张表中创建索引，也是可以避免全表扫描的
        

**子查询优化** **分组优化** **覆盖索引优化**

# Mybatis

配置文件中标签详情

-   configuration 根标签，无意义
    
    -   properties 属性标签，引入外部properties属性文件,定义属性值[key&value]
        
    -   settings ，是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。
        
    -   typeAliases ，为指定POJO或包下所有类定义缩写名
        
    -   environments标签，设置数据库连接环境
        
    -   mappers标签，设置映射文件路径
        

映射文件标签

-   select标签：定义查询语句
    
-   insert标签：定义增加语句
    
-   update标签：定义修改语句
    
-   delete标签：定义删除语句
    
-   sql标签：定义可重用的标签
    
-   cache标签：定义当前名称空间下的缓存配置
    
-   cache-ref标签：引用其他名称空间下的缓存配置
    
-   resultMap标签：自定义映射[类中的属性与表中字段的映射关系]
    
-   注意
    
    -   Mybatis中事务默认不提交[开启事务],如需增删改操作时,需要手动提交事务
        
        -   sqlSession.commit():提交事务
            
        -   sqlSession.rollback():回滚事务
            

获取主键自增数值 useGeneratedKeys

<insert id="insertEmployee" useGeneratedKeys="true" keyProperty="id">  
    INSERT INTO  
        tbl_employee(last_name,email,salary)  
    VALUES(#{lastName},#{email},#{salary})  
</insert>

Mybatis中参数传递问题

-   单个普通类型参数
    
    -   可以直接入参即可,不用考虑参数类型及名称
        
-   多个普通类型参数
    
    -   底层会将参数封装Map,Map的key是确定的为:arg0,arg1,...或param1,param2,...
        
-   命名参数
    
    -   需要2-3个参数时,又不支持POJO入参,此时使用命名参数
        

Mybatis自动映射与自定义映射

-   自动映射-resultType：指的是自动将表中的字段与类中的属性，建立映射关系。自动将结果集中的数据封装到对象中。
    
-   自定义映射-级联映射resultMap：的是自己将表中的字段与类中属性,建立映射关系。
    
-   自定义映射-association[多对一或一对一]
    
-   自定义映射-collection[一对多]
    

resultMap标签详解

-   属性
    
    -   id:定义resultMap标签唯一标识
        
    -   type:定义resultMap返回类型[目标方法返回类型]
        
-   子标签
    
    -   id标签:定义**主键**映射关系[类中的属性与表中字段]
        
    -   result标签:定义**非主键**映射关系
        
        -   property:定义映射属性[对象中]
            
        -   column:定义映射字段[表中]
            
    -   association标签:定义**多对一**映射关系
        
        -   property:定义映射属性
            
        -   javaType:定义映射属性**全类名**[全类名(类的全限定名)]
            
    -   collection标签:定义**一对多**映射关系
        
        -   property:定义映射属性
            
        -   ofType:定义映射属性[集合包含类型]**全类名**
            

动态标签

-   if 标签，用于完成简单的分支判断
    
-   where 标签，用于解决 **where 关键字** 及多出的**前面第一个**AND或OR问题
    
-   trim 标签，用于添加或去除前缀及后缀问题
    
    -   prefix：添加前缀
        
    -   prifixOverrides：去除前缀
        
    -   suffix：添加后缀
        
    -   suffixOverrides：去除后缀
        
-   set 标签，解决set关键字问题及多出的第一个逗号问题
    
-   choose when otherwise 标签 ，类似 java 中的 if-else
    
-   foreach标签:类似java中for
    
    -   collection:设置需要迭代的集合或数组
        
    -   item:设置迭代临时变量
        
    -   separator:设置分隔符
        
    -   open:设置循环**开始字符**
        
    -   close:设置循环**结束字符**
        
-   sql标签:定义可重用的SQL片段
    
    -   通过 include子标签 中的 refid 属性 引入
        

# Linux 指令

# Docker 指令

# JVM

# redis

## 为什么使用redis做缓存？

## 哪些地方用到了redis？

## 使用redis遇到了哪些问题，怎么解决的？

# 四. 后台商品管理模块(练习代码基本功)
#### 三级分类
	一级分类表
	二级分类表 中包含一级分类id
	三级分类表 中包含二级分类id
	面试题: 你们的三级分类用了几张表? 3张, 可以用一张吗?可以, pId字段
#### 品牌
	三级分类表
	品牌表
	中间表 为什么要有中间表: 品牌和三级分类是多对多的关系, 设计表结构的时候首先应该先判断关系, 一对一, 一对多, 多对对
	拿到需求: 
		第一步设计表结构, 
		第二步写model实体类pojo和vo, 
		第三步写Controller和Service先返回假数据, 最后进行实现
#### 平台属性和平台属性值
	表结构设计
		base_attr_info
		base_attr_value
		实际开发中: 先判断如果是空就直接返回, 尽量不要if嵌套, 最多嵌套三层
	具体接口实现
#### spu和sku
	Spu srandard product unit  标准化产品单元
	Sku stock keeping unit 库存量单位
#### spu销售属性和销售属性值
* 销售属性表 spu_sale_attr
* 销售属性值表  spu_sale_attr_value

#### spu基本信息表

spu_info



#### sku基本信息表

sku_info



#### sku关联平台属性表

sku_attr_value



#### sku的销售属性值表

sku_sale_attr_value



#### sku图片

sku_image



#### spu图片 spu海报 

spu_image

spu_poster


#### Spu sku业务实现

* 需求文档

​	![image-20221226102340069](image/电商总结/image-20221226102340069.png)

* 表设计结构

  

* 具体接口实现

  * 按照优化代码的思路去实现






#### 商品管理相关表结构
 ![后台表结构](image/电商总结/后台表结构.png)





#### 商品上架和下架 

* Sku_info表有一个字段？  is_sale 
* 数据怎么同步到es的goods？
  * 发送消息




#### 引进Rabbitmq
##### 作用
		流量削峰
		异步处理
		解耦服务
		
##### mq有哪些 

* rocket mq   java  万级吞吐量
* kafka    java    十万级吞吐量 ： 搭建spark集群   hadoop集群  去百度自己查查
* rabbitmq  erlang 万级吞吐量
* active mq   java 万级吞吐量

* qps: 每秒处理请求的数量
* tps: 每秒处理事务的请求数量
* 吞吐量（qps/tps）  单位时间内请求的数量

##### rabbitmq组成结构

* 简单画个图？
* ![image-20221226105802702](image/电商总结/image-20221226105802702.png)
	组成部分
		生产者
		消费者
		交换机
		队列
		routing kye
		binging
		broker服务
		
##### rabbitmq消息模型
- 简单模型 : 一对一, 一个生产者 队列 一个消费者
- 工作模型: 一对多 一个生产者 队列 多个消费者
- 发布订阅模型: 
	- 路由模型 fanout
	- 定向投递 direct
	- 通配投递 topic
		- excalidraw.com 画图工具

* 发布订阅模型图示：

  * 路由模型 fanout

    * ![image-20221226110222824](image/电商总结/image-20221226110222824.png)

  * 定向投递  direct

    * ![image-20221226110340737](image/电商总结/image-20221226110340737.png)

  * 通配投递 topic

    ![image-20221226110505986](image/电商总结/image-20221226110505986.png)

##### 面试题: 

###### 防止消息的重复消费

* 幂等性？ 就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的。

* set和setnx区别

  * ![image-20221226112554664](image/电商总结/image-20221226112554664.png)

* 怎么保证幂等性？

  * setnx可以 set不可以
  * redisson框架
  * 用mysql设置一个唯一值 （夯筑: 代码有问题导致大量请求落到mysql, 导致MySQL夯筑了）

  


###### 怎么保证消息不丢失（怎么保证消息的准确性）

* 生产者把消息投递到交换机，交换机把消息投递到队列，都可能引发消息丢失

  * 解决：生产者到交换机应答机制，交换机到队列的应答机制

* 服务端：消息是存储在内存中，如果服务挂了，消息就没了。

  * 解决：持久化    交换机和队列配置参数：durable = "true"

* 消费者：消息默认自动签收，只要消费者一监听，消息就出队了。

  * 解决：
    * 配置手动签收方式
    * basicAck

  

* 具体案例实现：

  * 生产者到交换机开启应答机制： publisher-confirm-type: correlated

    * publisher-confirm-type三种类型：

      * None 默认参数（不开启应答机制）
      * Simple  串行化 (同步)
      * correlated 异步

    * 重写了一个confrim方法 （生产者到交换机消息发送成功或者失败都调用重写方法）

      * 回调参数 ack 如果参数值是1 代表消息到达了交换机，如果是0代码没有到达交换机

        

  * 交换机到队列开启应答机制：

    * publisher-returns: true 

    * mandary:true

      * ```
        if (mandatory) {
          messageProperties.getHeaders().put(PublisherCallbackChannel.RETURN_LISTENER_CORRELATION_KEY, this.uuid);
        }
        ```

    * 重写了一个returnMessage方法（交换机到队列，失败回调）

    * 源码publisherCallbackChannelImpl方法handleReturn

    

    

  * 服务端broker

    * 交换机和队列配置  durable = true

    

    

  * 消费者

    * 配置手动签收方式
    * basicAck
    * channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);

    

    

###### 消息百分百投递： 
 三个方面保证消息的可靠：
		1. 生产端：应答机制，定义一个类，实现RabbitTemplate.ConfirmCallback,RabbitTemplate.ReturnCallback接口，实现方法：confirm(CorrelationData correlationData，boolean ack)和returnedMessage（）方法， 生产者发送消息到交换机时,将消息缓存到redis中， 失败时，broker会调用confirm（），如果成功发送到交换机，交换机在发送到队列时失败，broker调用returnedMessage（）方法。
		2. MQ服务端（brocker）：   消息持久化，消费端监听处 队列和交换机的参数后面的注解的参数：durable = "true",autoDelete = "false"开启持久化，关闭自动删除。（发送消息时通过设置deliveryMode=2持久化消息）
		3. 消费者端： 手动签收，在nacos配置文件中修改下面两个参数：
			   rabbitmq.listener.simple.acknowledge-mode: manual //默认情况下消息消费者是自动确认消息的，如果要手动确认消息则需要修改确认模式为

		   //手动确认  
         channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);

# rabbitmq



* rabbitmq

  * 作用是啥？
    * 流量削峰
    * 异步处理
    * 解耦服务

消息模型： 
	简单模式：一个生产者，一个队列，一个消费者
	工作模式： 一个生产者，一个队列，多个消费者（竞争）
	发布订阅模式：一个生产者，一个交换机，多个队列，多个消费者 
	路由模式：一个生产者，一个交换机，routingkey匹配 多个队列，，多个消费者   
	主题模式： 一个生产者，一个交换机，有通配符（`*代表匹配一个单词，#代表匹配多个单词`）的 routingkey匹配 多个队列，，多个消费者  
  rpc：不算
  rpc远程调用： 
	  原理： 

 ![](image/Pasted%20image%2020230203230726.png)
 ![](image/Pasted%20image%2020230203230748.png)
 ![](image/Pasted%20image%2020230203230312.png)

RabbitMQ用在哪几个模块： 
- order模块：延迟关单 
- product模块： 上下架
- active模块： 秒杀


消息百分百投递： 
	三个方面保证消息的可靠：
		1. 生产端：应答机制，定义一个类，实现RabbitTemplate.ConfirmCallback,RabbitTemplate.ReturnCallback接口，实现方法：confirm(CorrelationData correlationData，boolean ack)和returnedMessage（）方法， 生产者发送消息到交换机时,将消息缓存到redis中， 失败时，broker会调用confirm（），如果成功发送到交换机，交换机在发送到队列时失败，broker调用returnedMessage（）方法。
		2. MQ服务端（brocker）：   消息持久化，消费端监听处 队列和交换机的参数后面的注解的参数：durable = "true",autoDelete = "false"开启持久化，关闭自动删除。（发送消息时通过设置deliveryMode=2持久化消息）
		3. 消费者端： 手动签收，在nacos配置文件中修改下面两个参数：
			   rabbitmq.listener.simple.acknowledge-mode: manual //默认情况下消息消费者是自动确认消息的，如果要手动确认消息则需要修改确认模式为

		   //手动确认  
         channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);


RabbitMQ如何实现分布式事务：

![](image/Pasted%20image%2020230204010021.png)



## rabbitmq工作模式有哪些？

-   简单模式
    
-   工作模式
    
-   发布订阅模式
    
-   路由模式
    
-   通配符模式
    

## 哪些地方用到了消息队列？

-   取消订单，延迟关单
    
-   秒杀
    
-   商品上下架（同步数据到es）
    

## 遇到了哪些问题，怎么解决的？

消息丢失

-   如何解决？
    
    -   消费端：手动确认，在nacos配置中心
        
    -   生产端：应答机制，生产->交换机 ->队列
        
    -   服务端：持久化
        
        -   Exchange 开启持久化(durable=true)，关闭自动删除 (autoDelete=false)
            
        -   Queue 开启持久化(durable=true)，关闭自动删除(autoDelete=false)
            
        -   发送消息时，设置deliveryMode=2
            

重复消费

-   如何解决？
    
    -   redis幂等性 setnx
        

# 商品详情模块如何开发的

商品详情模块就是将商品的相关信息展示到页面上，包括商品所属分类、商品 sku 名称、商品价格、商品的销售属性、销售属性值、当前商品的选中状态、商品的图片、商品的海报、商品的平台属性等。考虑到该页面会被大量用户访问，做了一些优化，使用了 redis 对商品详情信息做了一个缓存来提高查询效率，并且使用多线程的异步编排把串行执行改为并行执行，来提高接口的执行效率。为了解决缓存击穿问题，我们在查数据库过程中使用了分布式锁，为了解决缓存穿透问题，使用了Redisson的布隆过滤器，后来对代码进行优化使用注解+AOP减少代码复用，大概是这样的一个开发思路。

## 缓存常见问题

缓存穿透: 是指查询一个不存在的数据，由于缓存无法命中，将去查询数据库，但是数据库也无此记录，并且出于容错考虑，我们没有将这次查询的 null 写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。 解决：空结果也进行缓存，但它的过期时间会很短，最长不超过五分钟。

缓存雪崩:是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。 解决：原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

缓存击穿: 是指对于一个设置了过期时间的 key，如果这个 key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：如果这个 key 在大量请求同时进来之前正好失效，那么所有对这个 key 的数据查询都落到 db，我们称为缓存击穿。 与缓存雪崩的区别：

1.  击穿是一个热点key失效
    
2.  雪崩是很多 key 集体失效
    

## 分布式锁是怎么实现的？

是使用 Redisson 实现的。 先根据定义的 key 值获取缓存的中的数据，判断一下数据如果为空，根据 skuId 查询数据库，可能会造成缓存击穿，所以在这个位置需要添加锁，使用的是 redissonClient. getLock (lockKey)，会返回一个 RLock lock 对象，使用 lock. TryLock () 尝试加锁并设置锁的持有时间，这个方法返回值类型是 Boolean， false，说明没拿到锁，让其睡眠 100 毫秒进行自旋， true，表示加锁成功，再查询数据库，由于可能从数据库中查询出来的数据可能是空值，空值会导致缓存穿透，为了避免缓存穿透是将空对象放入了缓存。Redisson底层有一个看门狗机制,可以实现锁的自动续期,如果锁到了过期时间但是仍然有线程持有锁,则会自动续期, 释放锁的原子性在底层也是用lua脚本解决的.

## 注解+AOP 减少代码复用是怎么实现的？

先自定义一个注解，使用元注解@Target (注解作用的地方)、@Retention（运行时）、@Inherited (注解可被继承)、@Documented（生成 javadoc 时是否有注解）定义，并设置一个字符串类型的默认前缀。将该注解添加到要使用缓存+分布式锁的方法上，设置前缀，在 AOP 切面上定义一个环绕通知将连接点设置为此注解，将分布式锁+缓存的业务代码添加在环绕通知中，实现减少代码的复用。

## 异步编排怎么实现 ？

是用到了 JUC 包下 CompletableFuture 实现类中的一些方法。通过 skuId 获取到 SkuInfo，使用 supplyAsync () 方法创建异步操作并提供返回值，通过 thenAcceptAsync () 消费处理结果。有返回值的使用 supplyAsync，无返回值的使用 RunAsync，最终通过 allOf 将多任务进行组合返回。

SupplyAsync 可以支持返回值。 RunAsync 方法不支持返回值。 ThenAccept 方法：接收任务的处理结果，并消费处理，无返回结果。 ThenApply 方法：当一个线程依赖另一个线程时，获取上一个任务返回的结果，并返回当前任务的返回值。 ThenRun 方法：只要上面的任务执行完成，就开始执行 thenRun，只是处理完任务后，执行 thenRun 的后续操作。

## 线程池怎么设计的？

线程池使用的是自定义线程池，设置了 7 个参数， CorePoolSize 大小设置为 50， MaxPoolSize 大小设置为 500， 存活时间设置为 30， 单位设置为秒， 阻塞队列设置为 ArrayBlockingQueue，大小设置为 1000， 线程工厂默认， 拒绝策略策略默认。

## 线程池的拒绝策略？

AbortPolicy: 直接抛异常，默认策略 CallerRunsPolicy:用调用者所在的线程来执行任务 DiscardOldstPolicy:丢弃阻塞队列中最靠前的任务，并执行当前任务 DiscardPolicy:直接丢弃任务

## 为什么要使用自定义线程池 ？

newFixedThreadPool 和 newSingleThreadExecutor 方法他们都使用了 LinkedBlockingQueue 的任务队列，LikedBlockingQueue 的默认大小为 Integer. MAX_VALUE。而 newCachedThreadPool 中定义的线程池大小为 Integer. MAX_VALUE。

禁止使用Executors创建线程池的原因就是FixedThreadPool和SingleThreadPool的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。

CachedThreadPool 允许的创建线程数量为 Integer. MAX_VALUE，可能会创建大量的线程，从而导致 OOM。

## 如何解决缓存击穿

Redisson 的布隆过滤器，在保存 sku 的时候把 skuId 存到布隆过滤器中，在调用商品详情页的时候先查布隆过滤器，如果布隆过滤器中不存在该 skuId，则直接返回不执行相关查询业务，如果有再执行。

## 布隆过滤器原理

布隆过滤器，可以看作是一个数据结构，他是以二进制的形式来存储数据。 当一个元素被加入集合时，通过 Hash 函数将一个元素映射成一个点，我们通过判断集合中是否存在 1 来确认是否存在当前元素，会产生误判，比如，元素 1 和元素 2，这两个元素同时将一个位置变为了 1（图 1 所示）。在这种情况下，我们就不能判定“元素 1”一定存在。如果是 0，可以确定当前元素一定不存在。

## 如何解决缓存雪崩

缓存雪崩的场景：大量key同时过期或Redis服务器宕机了，大量请求打到数据库。 解决方案：设置key的随机过期时间，搭建Redis集群

## Redis集群相关

哨兵模式（一主二从二哨兵）： 三主三从: 无中心集群架构，key 通过 hash 进入 hash 槽，三个主节点每个对应一部分 hash 槽，将数据分担在三个主机中，从机作用只是备份主机数据，当主机挂了从机上位。

## Redis 相关

**数据类型** string, list, set, zset, hash

**持久化** RDB: 定期对缓存数据进行快照，存储形式为二进制文件 AOF: 以日志的形式记录 redis 的写命令

**Redis 怎么保持热数据？Redis 内存满了咋办？** 内存淘汰策略：直接抛一个异常，不提供服务 有过期时间的：随机抛弃，抛弃剩余过期时间最短的，抛弃最近最少使用的 无过期时间的：随机抛弃，抛弃最近最少使用的

**缓存同步问题** 延迟双删：先删除缓存，更新数据库，更新完成后等待 500 毫秒（有从库的话要等待从库更新完毕），再删除缓存。

# 购物车模块是如何开发的

购物车模块是在详情页中点击添加到购物车按钮进入到购物车功能的，购物车模块设计的特点是购物车在缓存中采用 redis 的 [[03_项目功能设计与实现#购物车存储|hash]] 结构进行存储，且在用户未登录时商品可以添加到临时购物车，当用户登陆时临时购物车会合并到登录后的购物车中。

具体来说，当我们选中商品添加购物车时，前端会判断当前用户是否登录，若未登录会生成一个临时的用户 id 并放入 cookie 中。在后端会通过获取用户 id 来判断用户是否登录，若用户 id 为空则表示用户未登陆，将临时用户 id 赋值给用户 id，然后自定义了一个 key 将购物车数据存储到 redis 的 hash 结构中，key: 前缀+userId+后缀 field: 存放的是 skuId value: 存放的是商品信息。这个存储过程有两种情况，一种是购物车中已有相同的商品，这种情况下将商品从 redise 中取出将商品数量、选中状态、实时价格进行更新；第二种情况是购物车中没有相同的商品，那么直接将数据新增到缓存中。

[[03_项目功能设计与实现#合并购物车|合并购物车]]，我们需要明确什么时候合并，主要分为三种情况。用户未登录，通过临时用户 id 作为 key 从 redis 中获取未登录的购物车数据直接返回前端展示即可，不需要合并，第二种，用户已经登录，未登录时的购物车数据为空，根据用户 id 查询 redis 返回登录购物车数据，也不需要合并。第三种，当用户登录并且未登录时的购物车不为空，会触发合并，是将未登录的购物项合并到已登录的购物车，通过 steam 流遍历未登录的购物项，通过 hasKey()方法判断登录的购物车是否存在相同的商品，若存在相同商品，将数量相加，获取实时价格，设置选中状态，存储到 redis 中，若不存在相同商品，将未登录的购物车商品添加到已登录的购物车中，更新到 redis 中。完成合并清空未登录购物车数据。

# 订单模块是如何开发的？

我们在购物车列表点击结算，跳转到结算页，我们需要提供四部分数据，用户所有的收货地址，用户下单的购物项信息，总金额，总数量。然后在结算页点击提交订单会跳转到支付页面并且将这些数据保存到两张表中，order_Info 表和 order_detail 表，order_Info 表主要存储收货人的一些信息、订单状态，order_detail 表主要存储订单号和用户下单的购物项信息。考虑到浏览器存在回退，会导致重复提交问题，解决方法是在点击结算的时候生成一个唯一的流水号，将该流水号保存之 redis 中，再将流水号返回给前端页面保存，这样我们在提交订单的时候获取当前流水号与 redis 中的流水号进行比对，若不一致是不能提交订单的，一致才能提交订单，订单提交成功后，将 redis 中的流水号删除，再次回退到结算页点击提交订单是不会成功的，比对的时候 redis 中的已经被删掉了。删除流水号后订单业务需要验证库存和价格（使用 CompletableFuture 异步编排），通过 orderInfo 获取订单明细的集合，从集合中获取 skuId 和 skuNum 校验库存（用于拼接 url 通过 HttpClient 发送 get 请求实现），从库存管理系统中获取到结果，如果结果为 1 说明有库存，如果为 0 说明没库存，验证库存不足时给出某商品库存不足提示，验证实时价格是从数据库中根据 skuId 获取出商品价格与缓存中的价格比较，不同时给出某商品价格有变动提示，不执行保存订单，如果全都校验通过，则执行保存订单方法。执行保存订单方法时，需要设置订单状态为未支付、订单交易号（使用字符串+时间戳+随机数生成）等与订单相关信息，对 order_info 表和 order_detail 表进行新增。新增完毕后删除购物车中选中的商品并发送一个延迟消息。此时下单成功，跳转到支付页面，用户可以选择支付宝支付或是微信支付

对接支付模块具体来说，订单生成成功后，跳转到支付页面会携带订单的 id，用户可以选择支付方式，支付成功，支付模块会发送一个消息通知订单模块，订单模块要提供对应的监听器，此消息是 orderId，消费此消息来将订单状态改为已支付，并且订单还要发送一个消息通知库存，订单发送消息到库存后，订单状态修改为已通知仓库。

对接库存模块具体说，发送消息通知库存后，库存先判断当前这笔订单中的商品是否在一个仓库中，如果不在同一个仓库中，将不同的仓库所对应的商品集合为参数调用订单接口，订单接口提供对应的拆单方法，具体拆单方法是根据传参数的仓库与商品集合新建订单，将新建订单的 parentId 设为原来的订单 Id。库存出库成功后发送消息通知订单服务，订单的状态从已支付改为已发货。

对取消订单模块具体来说，当延迟消息被消费，此时判断订单状态，如果是未支付，才能 [[03_项目功能设计与实现#关单|关闭订单]] ，进行订单状态的修改，如果是已支付，就不用关闭订单了。

## 拆单怎么实现的？

新增订单，将父订单 id 设为原订单 id

## 防止超卖了吗？

没，为商场考虑，严格控制库存有可能造成压货

## 怎么防止超卖？

业务层面加分布式锁 Mysql 层面使用乐观锁或悲观锁

# 商品搜索模块是怎么开发的

商品搜索需要将商品信息同步到 ES 中，所以在商品在后台系统进行上下架的时候就需要将 ES 中商品相关数据信息进行更改，为了保持 ES 索引库与数据库数据一致，我采用了消息队列在更改上下架状态信息时发送一条消息，消息携带 SkuId，商品搜索模块监听此消息，判断 SkuId 不为空则调用上架 ES 方法，同时发送手动确认信息，确保数据同步成功。商品搜索有两个入口，一是首页展示的三级分类列表，二是搜索栏，他们的搜索条件封装到同一个 SearchParam 对象中，由前端传入。在我们的统一视图处理模块中远程调用商品搜索模块的 search 方法，将从 ES 中查到的结果进行封装返回，同时也会在统一视图处理模块对商品检索条件进行面包屑处理，将检索条件也统一封装到 SearchParam 对象中，以此来对商品进行检索。

1.你是如何将商品信息同步到ES中？ 在商品搜索模块监听到商品管理模块中商品上架时发送的消息后，执行同步方法，具体做法为新建一个商品信息对象，使用远程调用商品管理模块查询出来商品的SkuInfo信息，商品的品牌信息，商品的分类信息及商品的销售属性信息将这些消息封装到新建的商品信息对象中，使用ElasticSearchRepository<商品对象，ID类型>的实现，使用save方法进行持久化同步到ES中。（ElasticSearchResposity是Spring提供的操作ElasticSearch的数据层，封装了大量的基础操作，通过它可以很方便的操作ElasticSearch的数据）

2.搜索方法具体是怎样做的？ search方法的参数为前端传来的搜索条件，具体实现为构建DSL（领域特定语言）语句，使用客户端RestHighLevelClient执行DSL语句，对执行完毕后返回的结果进行处理封装返回。DSL语句的构建方式为为首先确定可以根据哪些条件进行检索，经过分析将检索条件定为：商品的分类ID、搜索栏查询关键字、商品品牌、商品属性的组合。先构建一个query的bool多条件查询，在多条件查询bool下将搜索栏关键字构建为must子句下的match query查询，因为match会对查询条件进行分词处理做到模糊查询，但是要加上operator的and操作，作用是分词后的所有词项必须在文档中全部包含才会命中，避免了细粒度分词带来的查询结果与预期不符问题；在多条件查询bool下将商品的面包屑属性查询构建为filter子句下的查询，因为面包屑属性不用参与计分(**全文检索以及任何使用相关性评分**的场景使用must检索，其余的使用filter检索，filter检索还会进缓存，Elasticsearch将创建一个文档匹配过滤器的位集bitset（如果文档匹配则为1，否则为0）。 随后用相同的过滤器执行查询将重用此信息。每当添加或更新新文档时，位集bitset也会更新。)，filter查询效率更快，所以将其构建为filter查询。构建查询条件完毕后接着构建属性聚合，属性聚合是为了在数据网格显示相关的面包屑属性，通过面包屑属性可以进行进一步的检索。接着构建ES分页，from代表开始索引（pageNo-1*pageSize），size代表每页大小。接下来构建排序，排序规则默认为热点排序，即商品详情页的访问量，如果带有排序条件，则根据所带的排序条件进行排序。排序构建完成以后，构建高亮显示，其作用为，在使用搜索栏检索时，将所输入的关键字高亮显示，具体实现为指定高亮显示的字段，给其加上前置标签与后置标签（标签内容为高亮的显示样式，如字体的颜色等）。高亮构建完毕后对检索的结果进行一个过滤，因为检索出来的字段，即在搜索后的商品详情页入口所显示的信息只需要显示商品的图片，商品的名称，商品的价格及进入商品详情页所需的SkuId，故将其他字段进行排除，至此DSL语句构建完成。

3.热点排序是怎么做的？

热点排序是在用户进入某个商品详情页时，给这个商品进行计数，最后根据计数对商品进行排序。具体实现为在用户进入详情页时，商品详情页异步编排进行查询详情数据时，异步执行一个远程调用商品搜索模块的增加热点值方法，此方法将热点值使用zset结构存入缓存，key定义为自定义字段表示商品热点，value定义为SkuId，此方法每被调用一次执行一次zset的incr，增量为1，使用redis模板类回去到这个热点值进行模100等0判断，取模的值根据商品的热点值更新速度判断，意为详情页每有100次点击再进行热点值持久到ES中，避免对ES频繁操作。（为什么用Redis的Zset结构，因为他自带score分数，符合应用场景。）

4.ES具体是怎么应用到项目中的？

在docker容器容启动ES将ik分词器配置在插件中，在项目中导入ES相关依赖

<**artifactId**>spring-boot-starter-data-elasticsearch</**artifactId**>

通过ElasticsearchRestTemplate的crateIndex（实体类.class）方法和putMapping（实体类.class）方法实现构建实体与ES mapping建立映射关系。（实体属性通过注解@Document(indexName = "goods" , shards = 3,replicas = 2)实现，indexNmae为索引库名称，shards为分片数，replicas为副本数）（mapping可以理解为ES的表结构，包含有定义字段的数据类型，存储形式等等），实体属性的选择商品的属性，其中将SkuName设为可分词属性，即可对商品名称进行分词查询，使用的中文分词器为ik_max_word，（通过注解@Field(type = FieldType.Text, analyzer = "ik_max_word")实现）平台属性集合对象设为Nested，即支持嵌套查询（通过注解@Field(type = FieldType.Nested)实现）。

5.ES集群？ 集群搭建、脑裂处理

## 商品的秒杀活动了解多少

商品秒杀模块的特点是商品购买有特定的时间，不到指定时间不能购买，每个商品参加秒杀活动的数量有限制，需要严格控制库存不能超卖，并且每个用户每个秒杀商品只能购买一次，对单个秒杀商品不能多次购买，还有秒杀的用户参与度比较高，尤其是热门商品的秒杀并发量大，需要解决高并发问题。

秒杀活动的大概流程是先采用定时任务，对当天需要参加秒杀活动的商品进行数据预热，预热过程中控制商品的可卖量，防止超卖，并且使用 redis 广播一个秒杀状态位，来判断商品是否处于可秒杀状态；数据预热完毕后分页展示秒杀商品和秒杀商品详情，从 redis 预热数据中查出所有参与秒杀的商品进行分页展示。在商品秒杀详情页有一个秒杀按钮，在可购买时间段内这个按钮才能使用，非购买时间段内被禁用，点击秒杀按钮还会生成一个抢购码，抢购码作为参数传给后台接口，后台接口校验抢购码，校验秒杀状态位，校验完了使用 rabbitMQ 发送消息把用户信息放到 mq 中进行排队，排队出来后开始预下单，也就是生成临时订单，生成临时订单前校验秒杀状态位，判断用户在排队过程中是否商品卖光了，秒杀活动是否已经结束。秒杀状态位校验通过后使用 redis 的 setNx 命令在 redis 中保存一个购买记录，key 为常量前缀+userId，value 为 skuId，如果不能保存成功，则说明是已经买过，如果能保存成功，则从 list 中获取一个库存量，如果能获取到，说明还有库存，则开始在 redis 中生成一个临时订单，临时订单采用的是 redis 的 hash 结构，存储的 key 是自定义字符串常量，field 是用户 id，value 是临时订单对象，临时订单的订单号设计为 skuId+userId 的 MD5 加密，最后进行更新库存，更新数据库库存，也更新缓存中的库存。前端在用户点击立即抢购按钮后开始定时轮询，调用后端接口，查看 redis 中是否有临时订单，如果没有临时订单，则给用户展示抢购中，如果有临时订单了，就给用户展示抢购成功页面，让用户去下单。秒杀模块远程调用订单模块的提交订单方法进行提交订单跳转支付，订单提交成功秒杀模块删除用户的临时订单，保留数据库中的下单记录，只要用户下过真实的订单，就提示抢购成功，用户可进入到我的订单查看该订单。下单成功后如果用户在指定的时间内完成支付，秒杀流程结束，如果未完成支付，则关闭订单，回滚数据库，把 redis 中的 list 新增一个商品，同时判断秒杀状态位是否是 0，如果为 0 则改为 1。再设置一个定时任务，清除 redis 中的已结束的秒杀商品的预热信息和用户购买记录。

不是主说模块，延伸问题再议...

# 简历中 专业技能可能引导出来的问题

1.  Java 集合体系，各种集合对应的数据结构，HashMap 底层原理，ArrayList 底层原理。
    
2.  MySQL的结构，引擎区别，索引失效，索引优化，Expain各个字段的含义，索引下推优化，聚簇索引非聚簇索引区别，B+树B树区别，MySQL执行顺序，当场写SQL。
    
3.  Redis介绍，数据类型，持久化，集群，缓存雪崩、穿透、击穿场景及其解决方案，Redisson的分布式锁，如果不用redisson怎么使用redis实现分布式锁，Redis的订阅与发布的使用。
    
4.  RabbitMQ消息中间件的介绍（docker，端口号），五种工作模式，如何使用，如何保证消息的可靠性，如何解决分布式事务，什么是分布式事务，延时队列怎么实现，为什么要使用插件方式实现延迟队列。消息的重复消费问题，如何保证消费幂等性。
    
5.  JVM都包含了哪些东西，每个东西中存了什么，JVM的垃圾回收机制，垃圾判定方法，垃圾回收算法，垃圾回收器，双亲委派机制。
    
6.  JUC是什么，线程进程区别，多线程创建的方式，线程的生命周期，线程池，线程池的拒绝策略，线程池的创建方式，为什么要用自定义线程池，阻塞队列，Copy on Write怎么实现，并发容器类，并发容器类（底层），多线程辅助类，AQS底层原理，读写锁，锁降级，Synchronized与Lock的区别，ReentrantLock了解多少。
    
7.  Spring是什么，IOC思想，AOP思想，（两个的底层实现），AOP的相关术语（连接点、切点、切面、通知），DI依赖注入，Spring的三级缓存如何解决循环依赖，SpringBean的生命周期，SpringMvc是什么，SpringMvc的执行流程，Mybatis是什么，Mybatis的动态SQL怎么实现，SpringMvc的核心注解。
    
8.  SpringBoot是什么，有什么优点，如何实现自动配置，核心注解是什么，如何实现自定义启动类，SpringCloud是什么，什么是微服务，SpringCloud用过哪些组件，Nacos原理，OpenFeign原理，Gateway如何使用（搭建模块说起），Sentinel如何使用（限流熔断降级规则），Sleuth（知道是干嘛的）。
    
9.  Nginx如何配置，反向代理，正向代理，负载均衡策略有哪些，静态资源如何部署。
    
10.  Linux基础指令有哪些？ cd、ls、ll、cat、chmod、vi、vim、touch、tail...
    
11.  ElementUI的基本知识（谁开发的），vue的双向绑定，钩子函数、thymeleaf的基础知识（数据如何取值，namespace如何配置）

