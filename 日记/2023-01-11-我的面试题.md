## 面试题:

### 1. 掌握Java基础，包括面向对象编程原理、Java集合体系、反射机制，并且有良好的编程习惯。

#### 什么是高内聚低耦合?
 - 低耦合就是模块之间的依赖要尽可能降低,每个模块作能够独立的完成一项任务,而不依赖其它模块,就是即使其它模块出现问题,也尽量不影响到当前模块的运行.
 - 高内聚就是模块内部的一个一个的类, 一个一个的方法,他们应该全部都为这个模块的总的功能而服务,应该将每一个方法的任务尽可能的细分,这样的话,当模块出现问题,我们能快速精确的定位到是哪个方法出现问题,只需要修改这个方法而不需要变动其它的方法.
 - 其实我们在实现低耦合,也就是尽可能降低模块间依赖的过程中也就无意间实现了高内聚,每个任务都被细致的划分到了每个模块,模块内部也就只会为了这一个任务而服务了. 所需要的参数和返回值都是清晰可见的,也就达到了易于开发和维护的目的.
参考原文:http://t.csdn.cn/TMh4S




#### 常见的编译时异常和运行时异常
编译时：文件找不到异常，类找不到异常，输入输出流异常，数据库操作异常（SQL异常），
运行时异常： 空指针异常，类型转换异常，内存溢出异常（OOM、SOF），算数异常，数组下标越界，参数不合法异常，

#### 两个字符串比较用什么方法 ? 如果要忽略大小写？
eqauls 方法，
如果要忽略大小写？
用equalsIgnoreCase 方法


#### this和super的底层实现原理?
this的底层实现是默认传值 , super是靠INVOKESPECIAL指令.
 - this: 我们创建一个对象时,实例化过程中会生成一个this指针和一个super指针,在用这个对象调用实例方法的时候,编译器会在我们的参数列表最前面加上当前对象,然后实例方法的形参列表最前面默认是有一个当前类型的this对象,然后就可以接收到传过去的对象,所以this就指向了当前对象,可以用this来调用其它的实例方法.
 - supper: 我们创建一个对象时, 初始化时会有一个INVOKESPECIAL指令,这个指令时用来调用一些需要特殊处理的实例方法,包括实例初始化方法,私有方法和父类方法, super就是通过INVOKESPECEAL指令调用父类方法的.
参考原文: http://t.csdn.cn/eCLYO


#### String类常用方法:
- 常见String类的获取功能
	1. length()  获取字符串长度
	2. charAt(int index)  传递一个下标参数，返回字符串对应位置的字符
	3. indexOf()  传递某个字符，返回在字符串中的第一个位置
	4. subString(int start)  默认是取到字符串末尾
	5. subString(int start, int end)  范围左闭右开，不包含下标为end的那位
- 常见String类的判断功能
	1. equals()  判断字符串内容是否相同，区分大小写
	2. contains() 判断该字符串是否包含传递过来的字符串
	3. startsWith(String prefix)  判断字符串是否以传进来的字符串开头
	4. endsWith(String suffix)   判断字符串是否以传进来的字符串结尾
	5. isEmpty()  判断字符串是否为空
- 常见String类的转换功能
	1. getBytes()   返回值类型 byte[] 使用平台的默认字符集将此 `String` 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。
	2. toCharArray()   将String类型的字符串转化为char字符数组
	3. valueOf(char[] data)   将传递的字符数组, 组合成字符串
	4. toLowerCase()  把字符串转成小写  
	5. toUpperCase()  把字符串转成大写
	6. concat(String str) 字符串拼接
- 常见String类的其它常用功能
	1. replace(char oldChar, char newChar)  用传递的字符或者字符串, 代替指定的字符或者字符串
	2. trim()   去除两端空格
	3. compareTo()  如果字符串与传递字符串的长度不等，那么返回就是两个字符串的长度差值；如果两个字符串长度相等，那么返回的就是，两个字符串长度最小值位置的字符ASCII码的差值。



#### 如何解决float和double精度损失问题？
可以使用BigDesimal, BigDesimal可以存储任意大小的数字，但是要注意创建BigDesimal对象时一定要传入一个字符串类型的数字“0.1”，而不是float类型的数字0.1,因为这个float类型或者double类型的0.1本身就是不精确的，它可能是：0.1
000000000000000055511151231257827021181583404541015625

#### ArrayList遍历时怎么删除元素?
ArraysList遍历有三种方式:
- for循环: 可以删除元素  
- forEach增强for循环(底层是迭代器遍历): 不可以删除元素,会报并发修改异常(ConcurrentModificationException), 即使不报异常, 执行结果也是错误的
- iterator迭代器遍历: 可以用iterator.remove()删除元素, 不能用list.remove(),否则也是会报并发修改异常(ConcurrentModificationException), 即使不报异常, 执行结果也是错误的
链接: http://t.csdn.cn/UXLcj

#### ArrayList 和 Vector 的区别？
 - ArrayList： 
	线程不安全的动态数组，数组初始化长度为 0，第一次添加的时候设置容量大小为10(懒加载思想，节约内存)，默认扩容为 1.5 倍。 
 - Vector： 
	线程安全的动态数组，数组初始化长度为 10，默认扩容为 2 倍。

#### ArrayList扩容？
无参初始化时，默认是空数组，第一次添加时，如果添加的个数小于10，设置容量为10，否则设置为需要的数量。当需要扩容时，会扩容到1.5倍，底层使用旧的容量右移一位（相当于除于2）然后加上旧的容量，其实就是1.5倍，扩容到1.5倍如果小于所需要的最小容量，就扩容为所需要的最小容量，如果大于Integer的最大值，就扩容为Integer的最大值。
参考链接：http://t.csdn.cn/Z8cbG

#### ArrayList、Vector 和 LinkedList 的区别 ？
 - ArrayList、Vector：
	动态数组 
	需要扩容。 
	非末尾位置增加、删除元素，需要移动元素。 
	ArrayList、Vector 实现List 接口。 
 - LinkedList：
	 双向链表 
	 不需要扩容和移动元素。 
	 LinkedList 实现List、Queue、Deque 接口。


#### Stack 和 LinkedList 的区别 ？
- Stack：是 Vector 的子类，是顺序栈，底层是数组。 
- LinkedList：是链式栈，底层是双向链表。

#### List 和 Set 的区别 ？
- List： 元素有序：元素的存储和添加顺序一致。 元素可重复。
- Set： 元素存储和添加顺序无关。 元素不可重复。

#### Hashtable 和 HashMap 的区别 ？
- Hashtable： 线程安全的，不允许 key 和 value 为 null 
- HashMap： 线程不安全的，允许 key 和 value 为 null

#### Hashtable 和 HashMap、TreeMap 的底层实现 ？
- Hashtable： 
	数组+链表 
- HashMap： 
	数组+链表/红黑树 
- TreeMap：
	红黑树

#### 哈希表的底层数组长度为什么是 2 的 n 次方 ?
因为 2 的 n 次方-1 的二进制值是前面都 0，后面几位都是 1，这样的话，与 hash 进行 &运算的结果就能保证在[0,table.length-1]范围内，而且是均匀的。

如果手动指定为一个非 2 的 n 次方的数组长度，HashMap 是否接收呢？如果不接收怎 么处理呢？
会纠正为>=手动指定的长度的最近的一个 2 的 n 次方值。

#### 哈希表的数组的元素类型
哈希表的数组的元素类型 java.util.Map$Entry 接口类型。
JDK1.7 的 HashMap 中有内部类Entry 实现 Entry 接口 
`JDK1.8 的 HashMap 中有内部类Node 和 TreeNode 类型实现Entry 接口，并且 TreeN ode 是 Node 的子类。`

#### 哈希表的键值对如何计算存储位置 ?
hash & table.length-1

#### 哈希表要用链表或红黑树？ 
为了解决hash 和[index]冲突问题 
（1） 两个不相同的key 的 hashCode 值本身可能相同 
（2） 两个不相同的key 的 hashCode 值不同，但是经过hash()运算，结果相同 
（3） 两个hashCode 不相同的key，经过hash()运算，结果也不相同，但是通过 hash & table.length-1 运算得到的[index]可能相同 

那么意味着 table[index]下可能需要存储多个Entry 的映射关系对象，所以需要链表或红黑树


#### HashMap 的数组什么时候扩容？
JDK1.7 版：当要添加新Entry 对象时发现（1）size 达到 threshold（2）table[index]!=null 时，两个条件同时满足会扩容 

JDK1.8 版：当要添加新Entry 对象时发现（1）size 达到 threshold（2）当 table [index]下的结点个数达到 8 个但是table.length 又没有达到 64。

两种情况满足其 一都会导致数组扩容 而且数组一旦扩容，不管哪个版本，都会导致所有映射关系重新调整存储位置。

#### 如何计算阈值 threshold ？
threshold = table.length * loadfactor

#### loadfactor 的默认值是多少 0.75

#### JDK1.8 的 HashMap 什么时候树化？为什么要树化？ 
当 table[index]下的结点个数达到 8 个, 而且是table.length 已经达到 64 
为什么要树化？ 
因为当table[index]下的结点个数超过 8 个后，查询效率就低下了，修改为红黑树 的话，可以提高查询效率

#### 某个链表节点数量达到8，但是数组长度不到64，会一直扩容，直到数组长度达到64，然后树化吗？
> 答： 不会， 因为HashMap每次扩容，桶的数量改变，然后元素的存放位置要重新计算，原来同一个链表上的八个节点可能就不再同一个链表上了，重新放到了不同的桶中，也就不满足链表节点数达到8，也就不会继续扩容了。


#### HashMap中的红黑树是什么 ？什么时候左旋右旋？
- 红黑树的数据结构是平衡二叉树，就是每个节点的左子节点比自己小，右子节点比自己大。
- 子节点的父节点和父节点的兄弟节点都是红的的时候就需要变色旋转了了，先变色再旋转，父节点和父节点的兄弟节点都变成黑色，爷爷节点变成红色，然后指针指向爷爷节点，进行适当的左旋或者右旋，最终变使它变为根节点，再改为黑色，原来的根节点变为红色。
参考链接： http://t.csdn.cn/jVKEj


#### DK1.8 的 HashMap 什么时候反树化？为什么要反树化？
当 table[index]下的树结点个数少于等于 6 个 
（1） 当继续删除table[index]下的树结点，最后这个根结点的左右结点有 null， 或根结点的左结点的左结点为 null，会反树化 
（2） 当重新添加新的映射关系到map 中，导致了 map 重新扩容了，这个时候如果table[index]下面还是小于等于 6 的个数，那么会反树化 

因为当table[index]下树的结点个数少于 6 个后，使用红黑树反而过于复杂了，此 时使用链表既简洁又效率也不错


#### 请问已经存储到 HashMap 中的 key 的对象属性是否可以修改？ 为什么？ 
如果该属性参与hashCode 的计算，那么不要修改。因为一旦修改hashCode()已经不 是原来的值。 
而存储到HashMap 中时，key 的 hashCode()-->hash()-->hash 已经确定了，不会 重新计算。
用新的 hashCode 值再查询get(key)/删除 remove(key)时，算的 hash 值与原来不一样就不找不到原来的映射关系了。

#### 如果 key 是 null，在HashMap中如何存储 ？
会存在table[0]中


#### TCP/UDP 协议有什么区别
- TCP：面向连接的可靠的基于字节流的传输控制协议 
- UDP：非面向连接的不可靠的基于用户数据报的协议


#### TCP三次握手，四次挥手简单说一下
#三次握手 #四次挥手
三次握手和四次挥手是为了保证TCP的可靠性的一个方面；
- 三次握手（建立连接）： 
	- 第一次： 客户端向服务器发送一个带有SYN 的连接请求报文；客户不确定自己能不能发送和接收
	- 第二次： 服务器向客户端发送一个带有SYN和ACK的确认报文；服务器确定能收到报文
	- 第三次： 客户端向服务器发发送一个带有ACK的确认报文;客户端确认能收到也发送，建立连接成功
- 四次挥手(断开连接)：
	- 第一次： 客户端向服务器发送一个带有FIN，seq1（序号）的结束请求报文；
	- 第二次： 服务器向客户端发送一个带有FIN和ACK,seq2的确认报文确认seq1的断开请求；
	- 第三次： 服务器向客户端再发送一带有FIN和ACK,seq3的确认报文确认seq1的断开请求；
	- 第四次： 客户端向服务器发送一个FIN,ACK,seq4的确认报文，确认seq3的确认信息。
	参考连接： http://t.csdn.cn/goriT


#### 计算机网络七层模型：
#七层网络模型 
应用层
表示层
会话层
网络层
传输层
数据链路层
物理层



#### 请你谈一下Java的反射机制


#### ==谈一谈你有哪些良好的编程习惯?==


### 2. 掌握MySQL，包括编写SQL语句和优化SQL。

#### MySQL有哪些语句
DQL 数据查询语言 查
DML 数据操纵语言 增删改
DDL 数据库定义语言
DCL 数据库控制语言

#### MySQL如何多表联查

#### MySQL聚合函数

#### 简单说一下groupBy_concat函数
#### MySQL有哪些约束,如何添加

#### 什么是事务
#### 事务的特性
#### 事务隔离级别， 以及存在的问题
#### 事务的传播行为
![](image/Pasted%20image%2020230113175140.png)
参考连接： https://www.bilibili.com/read/cv17284954
#### 如何开启事务
#### MySQL5和MySQL8的区别
#### 什么是sql注入， 如何解决
#### 数据库连接四大对象
#### 你知道哪些数据库连接池
#### MySQL的并发量是多少?

#### MySQL逻辑架构?

#### MySQL的存储引擎?
#### SQL预热是什么？

#### MySQL如何建立索引

#### MySQL索引失效问题?
#### 如何优化SQL?
#### 慢查询日志是什么？如何开启？
#### MySQL日志分析工具
#### MySQL视图，是什么， 作用， 适用场景，语法
#### MySQL分片是什么
#### MySQL分库分表




### 3. 掌握SpringMVC、Spring、Mybatis框架，理解Spring IOC、AOP思想，Mybatis动态SQL。

### 4. 熟练使用SpringBoot+SpringCloud进行微服务开发，包括Nacos、Sentinel、Openfeign、Gateway等组件。

### 5. 熟练使用消息中间件RabbitMQ，包括消息模型，消息确认机制，持久化，以及能够解决分布式事务问题。

### 6. 掌握Redis，包括数据类型、持久化机制、Redis主从和集群、使用Redis和Redisson实现分布式锁以及布隆过滤器。

#### redis 的内存淘汰策略（驱逐策略）(8种)？
内存满了
1. 不驱逐，直接抛异常
2. 最短时间者驱逐（ttl剩余最小）
3. 设置了ttl的key中随机驱逐一个
4. 所有key中随机驱逐一个
5. 设置了ttl的key中丢弃最近最少使用者驱逐
6. 所有key中最近最少使用者驱逐
7. 设置了ttl的key中使用频率最小的驱逐
8. 所有的key中使用过频率最少的驱逐
参考链接：http://cd.itheima.com/news/20220801/181457.html


### 7. 掌握nginx负载均衡、反向代理及常用配置。

### 8. 掌握创建和配置线程池，并熟练使用。

#### 线程池的拒绝策略（4种）？
阻塞队列已经满了，然后已开线程数达到最大线程数，则触发拒绝策略
1. 直接抛异常（默认）
2. 直接抛弃不处理
3. 将阻塞队列中的第一个弹出去（等待最久的抛弃），新来的排到最后
4. 哪个线程来请求，就让这个线程去处理（谁让我做事，我就让他自己做）
参考链接：http://t.csdn.cn/3rOG5

### 9. 熟练使用IntelliJ IDEA、Maven、Git等开发管理工具。

### 10. 熟悉七牛云OSS、阿里云OSS、Minio等云存储方案。

### 11. 熟悉Linux操作系统及常用命令以及docker常用命令。

### 12. 了解ES和Kibana，包括ik分词器。

### 13. 了解JVM，包括其内存结构、垃圾回收算法、OOM问题排查和优化。

### 14. 了解JUC 并发编程，包括创建和使用线程、线程生命周期以及安全容器、原子类和锁机制。







#### 什么是云原生？
 简单来说， 就是为了云而创造出来的技术。这些技术在云上运行更能发挥他们的优势。比如微服务框架Spring，SpringCloud组件等。
参考文献： https://zhuanlan.zhihu.com/p/150190166


#### 如何解决库存超卖问题？
加锁  synchronized
可以使用redis乐观锁提高效率，但是会出现库存遗留问题，
库存遗留问题可以用 lua脚本解决

#### lua脚本+redis解决库存遗留问题的原理？
redis+lua脚本解决库存遗留问题，实际上是利用了redis的单线程特性，使用了一个任务队列，将请求放到队列中，一个一个进行处理，也就是串行化了，避免了锁的争抢，而redis是基于内存的采用单线程+io多路复用技术，所以效率并不会降低.


#### RESTFull风格的请求有四种方式，但是浏览器一半只支持get和post，那么前端是怎么发起put和delete请求的？
前端请求的时候action用的是post,然后用到了隐藏的input标签，
`<input type="hidden" name="_method" value="put"/>`
name="`_method`", value="put"或者value="delete",
在后端有一个HiddenHttpMethodFilter过滤器，它将post请求转换成了put请求或者delete请求。在dofilterInternal方法中,获取到HttpServeletRequest对象,就是request对象，先判断请求方式为POST，并且获取过程没报错，这两个条件都满足后， 然后从request对象中获取"`_method`" 请求参数的值，先将它的值先转换成大写，用一个String类型的method来接收，(有一个常量List对象，这个对象中存储的两个值，一个是PUT,一个是DELETE)  然后判断method是不是被包含在这个常量List中，在的话就创建一个HttpServletRequestWrapper将原来的请求封装成method方式的请求，最后放行封装后的请求。

#### 线程安全问题是什么，如何解决 
当多个线程使用共享数据时，就会有线程安全问题。 
可以加同步 synchronized 解决。 
同步代码块或同步方法。 
同步代码块：手动选择同步锁对象。 
同步方法：静态方法的同步锁对象是当前类的Class 对象，
非静态方法的同步锁对象 是 this 对象


#### IO 流的四个抽象基类是什么
InputStream：字节输入流

OutputStream：字节输出流 
Reader: 字符输出流
 Writer：字符输出流

#### 如何实现对象序列化？ 
对象序列化需要用 ObjectOutputStream 的 writeObject 方法，对象的反序列化需 要用 ObjectInputStream 的 readObject 方法。 对象的类型需要实现java.io.Serializable 接口，并加序列化版本ID 加 transient 和 static 修饰的成员变量都不序列化

#### Class 类对象如何获取？
对象.getClass（）
类名.Class
Class.forName(全类名)
类加载器对象.loadClass(全类名)

#### 反射的作用？
实现 Java 语言的动态性。 
在运行时动态获取类信息，动态创建对象，动态操作属性，动态调用方法。


#### 什么是函数式接口？
只有一个抽象方法的接口，即 SAM 接口（Single Abstract Inteface）

#### 什么是 Lambda 表达式？
Lambda 表达式是一种实现函数式接口的新语法, 代替了匿名内部类的实现方式， jdk1.8引入的

#### 什么是方法引用？
方法引用是java8中特定情况下简化lambada表达式的一种语法糖，这里的特定情况是指`当调用现有的方法时`可以用方法引用替代lambada表达式，其他情况下，则不可以替代。
详情链接： http://t.csdn.cn/Nh3Jd

#### 举几个函数式接口的例子
java.lang.Runnable 
java.util.Comparator 
java.util.function.Consumer 
java.util.function.Predicate 
java.util.function.Supplier 
java.util.function.Function


#### Comparable 和 Comparator 的区别 
Comparable：自然比较接口 
Comparator：定制比较接口


#### Iterable 和 Iterator 的区别
Iterable：可迭代接口，实现它的集合就可以支持 foreach 循环遍历 
Iterator：迭代器接口

#### sleep() 和 wait() 有什么区别? 
sleep 和 wait 都会导致当前线程进入阻塞状态，被挂起。 
sleep 不释放锁，睡眠时间到自动醒来，回到就绪状态 
wait 是会释放锁，要通过 notify()或 notifyAll()唤醒，回到就绪状态 
sleep 是在 Thread 类中声明的一个静态方法，Thread.sleep(毫秒) 
wait 是在Object 类中声明的非静态的方法，必须锁对象调用

#### 线程的生命周期？
创建 就绪 运行 阻塞 死亡


#### 请列出一些常用的类、接口、包，各至少 5 个 注意答案不固定 
常用类：String，Math，ArrayList，HashMap，System,Arrays，LocalDate，Th read，HashSet，LinkedList 等 
常用接口：Comparable，Comparator，Runnable，Serializable，Collection， Map,List,Set,Iterator，Consumer，Predicate 等 
常用包：java.lang， java.util，java.io，java.net，java.text，java.lan g.reflect，java.time，java.util.function，java.math 等



#### 你知道哪些锁，分别介绍一下？




### 项目面试
SPU: 标准化产品单元
SKU: 库存量最小单位(最小库存单元)
参考乱接: http://t.csdn.cn/FnIAr













