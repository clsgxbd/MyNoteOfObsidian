
## 购物车
添加购物的实现思路: 
	判断用户是否登录, 已登录, 则根据用户id获取用户购物车, 未登录, 则根据临时id获取临时购物车. 判断购物车中是否存在当前要添加的商品信息, 如果已经存在, 则更新商品数量,选中状态,价格,时间, 更新到redis临时购物车.如果不存在, 则封装一个商品信息. 最终添加到redis购物车.

购物车列表的实现思路: 
	点击购物车列表, 判断是否登录, 没登陆的话, 直接展示未登录的购物车列表信息. 已经登录的话, 判断未登录的购物车信息是否为空, 为空, 直接展示已登录的购物车信息, 不为空, 合并购物车, 判断登录的和未登录的sku_id是否相同, 不相同, 未登录的购物车商品信息添加到已登录的购物车信息中, 相同, 则更新登录的购物车的商品的数量,时间,选中状态., 更新到redis存储. 最终不管是否合并购物车, 删除未登录的购物车数据. 


## 订单
结算页数据展示
	结算页接口数据
		- 收获地址
		- 商品信息(redis购物车数据)
		- 总金额
		- 总数量
		- 流水号(隐藏表单)
	流水号作用 #流水号
		防止浏览器回退重复提交订单

保存下单
	保存存入了哪几张表
		订单表
		订单明细表
	outTradeNo: 用来标识该订单

保存下单流程: 
	校验流水号
	校验库存
	校验价格
	保存订单信息order_info
		- order_id
		- user_id
		- total_amount总价格
		- order_status订单状态
		- out_trade_no第三方编号
	保存订单详情信息order_detail
		- sku_id
		- sku_price
		- sku_num
		- order_id

延迟关单
	关单的业务逻辑
		- 判断订单是否存在
		- 判断是否存在本地交易记录
		- 判断支付宝是否存在交易记录
		- 关闭支付宝的未支付记录
		- 判断是否关闭成功
		- 改变本地订单状态为已失效
	实现方式
		#延迟消息 


## 支付
- 微信
- 支付宝
- 银联
- 块钱支付 - 万达收购了 - 京东并购 

支付宝的使用
![](image/Pasted%20image%2020221227114137.png)

支付接口
	- 封装公共参数
		appid 支付成功url地址 同步回调地址 异步回调地址
	- 判断订单状态
	- 封装必填参数
		```
		JsONObject jsonObject = new JsONObjectO;// 商户订单号jsonObject.put("out_trade_no",orderInfo.getOutTradeNo());jsonObject .put("total_amount",0.01);jsonObject .put("subject",orderInfo.getTradeBody());jsonobject.put("product_code"，"QUICK_WAP_WAY"); // 手机网站
		```
	- 调用支付宝支付接口

同步回调
	- 支付宝有一个3s或5s, 之后跳转到我们自己电商一个url地址
		- http://api.gmall.com/api/payment/alipay/callback/return
	- 支付回调地址作用: 重定向到我们自己的支付成功页面

<mark>异步回调</mark>
	- SDK验证签名
	- 判断支付信息表是否存在
	- 判断金额是否相等
	- 幂等性校验
	- 更新支付表信息
		- trade_no 交易编号 写死的这个字段,支付宝给传来的 <mark>很重要奥</mark>
		- 更新支付状态 -- 变成已支付
		- 更新支付时间
		- 返回success 标志最终支付成功

退款接口
	- 根据订单id查询订单信息
	- 订单如果关闭 不处理
	- 根据第三方交易编号和订单总金额 去调用支付宝退款接口

支付宝关闭校验和交易查询接口
![](image/Pasted%20image%2020221227143623.png)

面试问支付我们要知道哪些
	- 支付宝支付接口穿了哪些参数(必传的) 
		- out_trade_no 第三方交易编号
		- total_amount 总金额
		- 标题
	- 公共参数有哪些
		- 最重要的 app_id
		- 同步回调地址
		- 异步回调地址
		- 支付成功地址
	- ![](image/Pasted%20image%2020221227144015.png)


## 秒杀
作用
	- 电商秒杀 - 促销
	- 提升购买率, 饥饿营销

三大限制
	- 库存限制
	- 购买时间限制
	- 购买数量限制

秒杀流程
	准备工作 数据<mark>预热(最重要)</mark>
		- 后台添加商品, 审核商品到秒杀商品数据表(skill_goods status 0 未审核, 1 审核成功) 
		- 定时任务, 发送一个mq, 通知秒杀活动, 进行预热
		- 秒杀服务按照一定的条件把skilll_goods 预热, 预热了哪些数据并且存入到了哪里?
			- 存入redis
			- redis数据结构
				- 商品: hash key:常量 field:sku_id value:商品信息
				- 商品库存 list key:7 value:[7,7,7,7,7]
		- 发布频道, 消息为7:1 -> 最终存入静态变量 cacheMap(堆中)
		- 7:1 作用?
			- 7: 商品id
			- 1: 状态位 (标志有没有库存). 1: 有库存  0:没有库存
			- 7:[7,7,7,7,7]  来改变状态位的标识, 如果值为[], 状态位为0 
		- 为什么要用发布订阅?
			- 分布式模块之间的静态变量通知
		- 7:1 直接扔到redis也可以?
			- 可以
			- 为什么没有扔到redis, 而是使用发布订阅+静态变量的方式
				- 从redis拿7:1和从堆中拿7:1哪个快?为什么?
					- 堆中快
					- 堆中拿数据不经过网络传输,redis需要网络传输
		- 发布订阅流程图
			![](image/Pasted%20image%2020221227154452.png)



## tinyint
#tinyint
字段类型tinyint只占一个字节, 状态啥的可以用这个类型
