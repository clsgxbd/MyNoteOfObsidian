课件:   #MySQL8高级


rouws 预估要检索的行数
Extra 包含不适合在其他列中显示但十分重要的额外信
* Using index:(重要指标): 使用了覆盖索引,是高性能的表现
* Using filesort:(重要指标): 如果排序操作无法使用到索引,只能在内存中(记录较少时)或者磁盘中(记录较多时)进行排序(filesort) 无法利用索引完成的排序 操作称为**文件排序**, 是性能较低的条件
* Using where:(一般重要指标):用了where,但在where上有字段没有创建索引,查询未被索引覆盖
* Using join buffer:(一般重要指标): 表明使用了连接缓存,在连接查询时,当被驱动表不能有效利用索引时MySQL会提前申请一块内存空间(join brffer)存储驱动表的数据,来加快查询速度

#MySQL索引下推: 尽可能的将可以利用到索引的条件进在索引中查询,推迟回表时机

#单表索引失效案例

#关联查询优化:
左外连接:
	小表驱动大表,大表关联字段建立索引
	如果小表关联字段额外有where条件可以给小表该字段也建立索引,否则没必要给小表字段建立索引
内连接: 
* 在都有索引的情况下: 优化器会自动优先小表驱动大表
* 只有一个表有索引的情况:  优化器会自动将有索引的表作为被驱动表
* 两张表都没有索引的情况下: 同样优化器会自动小表驱动大表

子连接: 
	反正尽量别用子连接
	能建立索引就建立索引


#索引失效 的情况
以下三种情况不走索引：
无过滤,不索引: 
	没过滤条件就不会走索引,实在没条件就加limit
顺序错,不索引: 
	查询条件的顺序应该和复合索引中的列顺序一致
	order by 中的字段走了索引也不在key_len中体现
方向反,不索引: 
	从小到大排列 ASC



总结: 
	重点: 性能的优化
		用户反馈
		慢日志查询
		指标 分析sql面临的问题 尤其是有索引 没走的 
		用户执行的sql拿过来模拟
	单表索引失效
	关联查询优化
	尽可能避免写子查询
	索引失效的情况
	慢日志查询
	view视图
	今天的命令要自己执行一遍





























