## 面试题:

### 1. 掌握Java基础，包括面向对象编程原理、Java集合体系、反射机制，并且有良好的编程习惯。
**
#### 什么是高内聚低耦合?
 - 低耦合就是模块之间的依赖要尽可能降低,每个模块作能够独立的完成一项任务,而不依赖其它模块,就是即使其它模块出现问题,也尽量不影响到当前模块的运行.
 - 高内聚就是模块内部的一个一个的类, 一个一个的方法,他们应该全部都为这个模块的总的功能而服务,应该将每一个方法的任务尽可能的细分,这样的话,当模块出现问题,我们能快速精确的定位到是哪个方法出现问题,只需要修改这个方法而不需要变动其它的方法.
 - 其实我们在实现低耦合,也就是尽可能降低模块间依赖的过程中也就无意间实现了高内聚,每个任务都被细致的划分到了每个模块,模块内部也就只会为了这一个任务而服务了. 所需要的参数和返回值都是清晰可见的,也就达到了易于开发和维护的目的.
参考原文:http://t.csdn.cn/TMh4S




#### 常见的编译时异常和运行时异常
编译时：文件找不到异常，类找不到异常，输入输出流异常，数据库操作异常（SQL异常），
运行时异常： 空指针异常，类型转换异常，内存溢出异常（OOM、SOF），算数异常，数组下标越界，参数不合法异常，

#### 两个字符串比较用什么方法 ? 如果要忽略大小写？
eqauls 方法，
如果要忽略大小写？
用equalsIgnoreCase 方法


#### this和super的底层实现原理?
this的底层实现是默认传值 , super是靠INVOKESPECIAL指令.
 - this: 我们创建一个对象时,实例化过程中会生成一个this指针和一个super指针,在用这个对象调用实例方法的时候,编译器会在我们的参数列表最前面加上当前对象,然后实例方法的形参列表最前面默认是有一个当前类型的this对象,然后就可以接收到传过去的对象,所以this就指向了当前对象,可以用this来调用其它的实例方法.
 - supper: 我们创建一个对象时, 初始化时会有一个INVOKESPECIAL指令,这个指令是用来调用一些需要特殊处理的实例方法,包括实例初始化方法,私有方法和父类方法, super就是通过INVOKESPECEAL指令调用父类方法的.
参考原文: http://t.csdn.cn/eCLYO


#### String类常用方法:
- 常见String类的获取功能
	1. length()  获取字符串长度
	2. charAt(int index)  传递一个下标参数，返回字符串对应位置的字符
	3. indexOf()  传递某个字符，返回在字符串中的第一个位置
	4. subString(int start)  默认是取到字符串末尾
	5. subString(int start, int end)  范围左闭右开，不包含下标为end的那位
- 常见String类的判断功能
	1. equals()  判断字符串内容是否相同，区分大小写
	2. contains() 判断该字符串是否包含传递过来的字符串
	3. startsWith(String prefix)  判断字符串是否以传进来的字符串开头
	4. endsWith(String suffix)   判断字符串是否以传进来的字符串结尾
	5. isEmpty()  判断字符串是否为空
- 常见String类的转换功能
	1. getBytes()   返回值类型 byte[] 使用平台的默认字符集将此 `String` 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。
	2. toCharArray()   将String类型的字符串转化为char字符数组
	3. valueOf(char[] data)   将传递的字符数组, 组合成字符串
	4. toLowerCase()  把字符串转成小写  
	5. toUpperCase()  把字符串转成大写
	6. concat(String str) 字符串拼接
- 常见String类的其它常用功能
	1. replace(char oldChar, char newChar)  用传递的字符或者字符串, 代替指定的字符或者字符串
	2. trim()   去除两端空格
	3. compareTo()  如果字符串与传递字符串的长度不等，那么返回就是两个字符串的长度差值；如果两个字符串长度相等，那么返回的就是，两个字符串长度最小值位置的字符ASCII码的差值。
	4. String[] split(String regex) 按照规则拆分字符串, 返回一个字符串数组


#### 如何解决float和double精度损失问题？
可以使用BigDesimal, BigDesimal可以存储任意大小的数字，但是要注意创建BigDesimal对象时一定要传入一个字符串类型的数字“0.1”，而不是float类型的数字0.1,因为这个float类型或者double类型的0.1本身就是不精确的，它可能是：0.1000000000000000055511151231257827021181583404541015625

#### ArrayList遍历时怎么删除元素?
ArraysList遍历有三种方式:
- for循环: 可以删除元素  
- forEach增强for循环(底层是迭代器遍历): 不可以删除元素,会报并发修改异常, 即使不报异常, 执行结果也是错误的
- iterator迭代器遍历: 可以用iterator.remove()删除元素, 不能用list.remove(),否则也是会报并发修改异常, 即使不报异常, 执行结果也是错误的
当modCount != expectdModCount时，抛出并发修改异常(ConcurrentModificationException)
链接: http://t.csdn.cn/UXLcj

#### ArrayList 和 Vector 的区别？
 - ArrayList： 
	线程不安全的动态数组，数组初始化长度为 0，第一次添加的时候设置容量大小为10(懒加载思想，节约内存)，默认扩容为 1.5 倍。 
 - Vector： 
	线程安全的动态数组，数组初始化长度为 10，默认扩容为 2 倍。

#### ArrayList扩容？
无参初始化时，默认是空数组，第一次添加时，如果添加的个数小于10，设置容量为10，否则设置为需要的数量。当需要扩容时，会扩容到1.5倍，底层使用旧的容量右移一位（相当于除于2）然后加上旧的容量，其实就是1.5倍，扩容到1.5倍如果小于所需要的最小容量，就扩容为所需要的最小容量，如果大于Integer的最大值，就扩容为Integer的最大值。
参考链接：http://t.csdn.cn/Z8cbG

#### ArrayList、Vector 和 LinkedList 的区别 ？
 - ArrayList、Vector：
	动态数组 
	需要扩容。 
	非末尾位置增加、删除元素，需要移动元素。 
	ArrayList、Vector 实现List 接口。 
 - LinkedList：
	 双向链表 
	 不需要扩容和移动元素。 
	 LinkedList 实现List、Queue、Deque 接口。


#### Stack 和 LinkedList 的区别 ？
- Stack：是 Vector 的子类，是顺序栈，底层是数组。 
- LinkedList：是链式栈，底层是双向链表。

#### List 和 Set 的区别 ？
- List： 元素有序：元素的存储和添加顺序一致。 元素可重复。
- Set： 元素存储和添加顺序无关。 元素不可重复。

#### HashMap的遍历方式?
常用的有四种:
1. map.keySet()方法获取到key的集合, 然后进行遍历, 调用map.get(key)获取value值
2. map.entrySet()方法, 获取到所有的entry对象, 然后用增强for循环进行遍历
3. map.entrySet()方法,获取到所有的entry对象, 然后用Interator迭代器
#### Hashtable 和 HashMap 的区别 ？
- Hashtable： 线程安全的，不允许 key 和 value 为 null 
- HashMap： 线程不安全的，允许 key 和 value 为 null
#### HashTable和ConcurrentHashMap的区别?
- HashTable :使用了synchronized关键字对put等操作进行加锁
- ConcurrentHashMap JDK1.7 : 使用分段锁机制实现:
- ConcurrentHashMap JDK1.8:则使用数组+链表+红黑树数据结构和CAS原子操作实现,对每个桶加锁

#### Hashtable 和 HashMap、TreeMap 的底层实现 ？
- Hashtable： 
	数组+链表 
- HashMap： 
	数组+链表/红黑树 
- TreeMap：
	红黑树

#### 哈希表的底层数组长度为什么是 2 的 n 次方 ?
因为 2 的 n 次方-1 的二进制值是前面都 0，后面几位都是 1，这样的话，与 hash 进行 &运算的结果就能保证在[0,table.length-1]范围内，而且是均匀的。

如果手动指定为一个非 2 的 n 次方的数组长度，HashMap 是否接收呢？如果不接收怎 么处理呢？
会纠正为>=手动指定的长度的最近的一个 2 的 n 次方值。

#### 哈希表的数组的元素类型
哈希表的数组的元素类型 java.util.Map$Entry 接口类型。
JDK1.7 的 HashMap 中有内部类Entry 实现 Entry 接口 
`JDK1.8 的 HashMap 中有内部类Node 和 TreeNode 类型实现Entry 接口，并且 TreeNode 是 Node 的子类。`

#### 哈希表的键值对如何计算存储位置 ?
hash & table.length-1

#### 哈希表要用链表或红黑树？ 
为了解决hash 和[index]冲突问题 
（1） 两个不相同的key 的 hashCode 值本身可能相同 
（2） 两个不相同的key 的 hashCode 值不同，但是经过hash()运算，结果相同 
（3） 两个hashCode 不相同的key，经过hash()运算，结果也不相同，但是通过 hash & table.length-1 运算得到的[index]可能相同 

那么意味着 table[index]下可能需要存储多个Entry 的映射关系对象，所以需要链表或红黑树


#### HashMap 的数组什么时候扩容？
JDK1.7 版：当要添加新Entry 对象时发现（1）size 达到 threshold（2）table[index]!=null 时，两个条件同时满足会扩容 

JDK1.8 版：当要添加新Entry 对象时发现（1）size 达到 threshold（2）当 table [index]下的结点个数达到 8 个但是table.length 又没有达到 64。

两种情况满足其 一都会导致数组扩容 而且数组一旦扩容，不管哪个版本，都会导致所有映射关系重新调整存储位置。

#### 如何计算阈值 threshold ？
threshold = table.length * loadfactor

#### loadfactor 的默认值是多少 0.75

#### JDK1.8 的 HashMap 什么时候树化？为什么要树化？ 
当 table[index]下的结点个数达到 8 个, 而且是table.length 已经达到 64 
为什么要树化？ 
因为当table[index]下的结点个数超过 8 个后，查询效率就低下了，修改为红黑树 的话，可以提高查询效率

#### 某个链表节点数量达到8，但是数组长度不到64，会一直扩容，直到数组长度达到64，然后树化吗？
> 答： 不会， 因为HashMap每次扩容，桶的数量改变，然后元素的存放位置要重新计算，原来同一个链表上的八个节点可能就不再同一个链表上了，重新放到了不同的桶中，也就不满足链表节点数达到8，也就不会继续扩容了。


#### HashMap中的红黑树是什么 ？什么时候左旋右旋？
- 红黑树的数据结构是平衡二叉树，就是每个节点的左子节点比自己小，右子节点比自己大,左右子树高度差不超过1。
- 子节点的父节点和父节点的兄弟节点都是红的的时候就需要变色旋转了了，先变色再旋转，父节点和父节点的兄弟节点都变成黑色，爷爷节点变成红色，然后指针指向爷爷节点，进行适当的左旋或者右旋，最终变使它变为根节点，再改为黑色，原来的根节点变为红色。
参考链接： http://t.csdn.cn/jVKEj


#### DK1.8 的 HashMap 什么时候反树化？为什么要反树化？
当 table[index]下的树结点个数少于等于 6 个 
（1） 当继续删除table[index]下的树结点，最后这个根结点的左右结点有 null， 或根结点的左结点的左结点为 null，会反树化 
（2） 当重新添加新的映射关系到map 中，导致了 map 重新扩容了，这个时候如果table[index]下面还是小于等于 6 的个数，那么会反树化 

因为当table[index]下树的结点个数少于 6 个后，使用红黑树反而过于复杂了，此 时使用链表既简洁又效率也不错


#### 请问已经存储到 HashMap 中的 key 的对象属性是否可以修改？ 为什么？ 
不可以
如果该属性参与hashCode 的计算，那么不要修改。因为一旦修改hashCode()已经不 是原来的值。 
而存储到HashMap 中时，key 的 hashCode()-->hash()-->hash 已经确定了，不会 重新计算。
用新的 hashCode 值再查询get(key)/删除 remove(key)时，算的 hash 值与原来不一样就不找不到原来的映射关系了。

#### 如果 key 是 null，在HashMap中如何存储 ？
会存在table[0]中


#### TCP/UDP 协议有什么区别
- TCP：面向连接的可靠的基于字节流的传输控制协议 
- UDP：非面向连接的不可靠的基于用户数据报的协议


#### TCP三次握手，四次挥手简单说一下
#三次握手 #四次挥手
三次握手和四次挥手是为了保证TCP的可靠性的一个方面；
- 三次握手（建立连接）： 
	- 第一次： 客户端向服务器发送一个带有SYN 的连接请求报文；客户不确定自己能不能发送和接收
	- 第二次： 服务器向客户端发送一个带有SYN和ACK的确认报文；服务器确定能收到报文
	- 第三次： 客户端向服务器发发送一个带有ACK的确认报文;客户端确认能收到也发送，建立连接成功
- 四次挥手(断开连接)：
	- 第一次： 客户端向服务器发送一个带有FIN，seq1（序号）的结束请求报文；
	- 第二次： 服务器向客户端发送一个带有FIN和ACK,seq2的确认报文确认seq1的断开请求；
	- 第三次： 服务器向客户端再发送一带有FIN和ACK,seq3的确认报文确认seq1的断开请求；
	- 第四次： 客户端向服务器发送一个FIN,ACK,seq4的确认报文，确认seq3的确认信息。
	参考连接： http://t.csdn.cn/goriT


#### 计算机网络七层模型：
#七层网络模型 
应用层
表示层
会话层
网络层
传输层
数据链路层
物理层



#### 请你谈一下Java的反射机制?


#### Date类对象和字符串的相互转换
用SimpleDateFormat对象, 创建对象的时候指定字符串的格式, `例如new SimpleDateFormat("yyyy:MM:dd HH:mm:ss");` 
用parse(String str)方法 字符串->Date对象
用format(Date date)方法  Date对象->字符转

在Spring中封装了一个注解: @DateTimeFormat(pattern = "yyyy-MM-dd")

#### File文件类有哪些API? #File类API
```
API
- public String getName()  ：返回由此File表示的文件或目录的名称。
- public long length()  ：返回由此File表示的文件的长度。
           length()方法可以获取文件的大小，不能直接获取文件夹的大小
           如果要获取文件夹的大小？
           A：找第三方的工具类
           B：自己写代码（递归/循环）统计文件夹下所有文件的大小总和
- public String getPath() ：将此File转换为路径名字符串。
- public long lastModified()：返回File对象对应的文件或目录的最后修改时间（毫秒值）

- public boolean exists() ：此File表示的文件或目录是否实际存在。
- public boolean isDirectory() ：此File表示的是否为目录。
- public boolean isFile() ：此File表示的是否为文件。
- public boolean canRead()
- public boolean canWrite()
...

- public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。
- public boolean delete() ：删除由此File表示的文件或目录。  只能删除空目录。
- public boolean mkdir() ：创建由此File表示的目录。
- public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。

    注意：
    A：创建文件和文件夹的方法不同
    B：创建多级文件夹用mkdirs()
    C：如果删除文件夹时，文件夹里面非空，那么直接调用delete()是无法删除的

    如何删除非空文件夹呢？
    A：找第三方的工具类
    B：自己写代码（递归/循环）删除文件夹下所有下一级


- public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。
- public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。
- public File[] listFiles(FileFilter filter)：返回所有满足指定过滤器的文件和目录。如果给定 filter 为 null，则接受所有路径名。否则，当且仅当在路径名上调用过滤器的 FileFilter.accept(File pathname)方法返回 true 时，该路径名才满足过滤器。如果当前File对象不表示一个目录，或者发生 I/O 错误，则返回 null。
- public String[] list(FilenameFilter filter)：返回返回所有满足指定过滤器的文件和目录。如果给定 filter 为 null，则接受所有路径名。否则，当且仅当在路径名上调用过滤器的 FilenameFilter .accept(File dir, String name)方法返回 true 时，该路径名才满足过滤器。如果当前File对象不表示一个目录，或者发生 I/O 错误，则返回 null。
- public File[] listFiles(FilenameFilter filter)：返回返回所有满足指定过滤器的文件和目录。如果给定 filter 为 null，则接受所有路径名。否则，当且仅当在路径名上调用过滤器的 FilenameFilter .accept(File dir, String name)方法返回 true 时，该路径名才满足过滤器。如果当前File对象不表示一个目录，或者发生 I/O 错误，则返回 null。

```


#### 输入输出流? #IO流

```
1、为什么有File类之后，还要有IO流？
如果要操作文件里面的内容，需要使用IO流才可以。
如果要在两个程序之间进行数据的交互，也需要使用IO流。

IO流的API：
（1）传统IO流，最基础的IO流，单向IO流。
（2）NIO：非阻塞式IO流
（3）AIO：异步IO流

2、IO流的类型（咱们今天讲的是传统IO流）
（1）按照方向分：
输入流：InputStream系列、Reader系列
    只能从输入流中“读read”数据。
输出流：OutputStream系列、Writer系列
    只能往输出流中“写write/print”数据

（2）按照操作数据的方式、单位不同：
字节流：以字节为单位，适用于读/写任意类型的数据
    InputStream系列、OutputStream系列
字符流：以字符为单位，只能用于读/写纯文本的数据，char[],String
    Reader系列、Writer系列

（3）按照IO流的角色分：
节点流：负责和节点（例如：文件、网络通道）连接的IO流
     文件IO流：FileInputStream、FileOutputStream、FileReader、FileWriter
     字节数组IO流：ByteArrayInputStream、ByteArrayOutputStream
     字符数组IO流：CharArrayReader、CharArrayWriter
     管道IO流：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter
处理流：负责给节点流增加功能
    缓冲IO流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter
    编码和解码IO流（转换流）：InputStreamReader、OutputStreamWriter
    对象IO流：ObjectInputStream、ObjectOutputStream
    数据IO流：DataInputStream、DataOutputStream
    打印流：PrintStream、PrintWriter

3、IO流的四大抽象基类：
InputStream：字节输入流
OutputStream：字节输出流
Reader：字符输入流
Writer：字符输出流
```


#### 反射
#### 多线程
##### ThreadLocal基本使用和原理
1.概述:可以看做是一个容器,专门放变量或者对象的
2.方法:
  void set(T value)-> 往ThreadLocal中存数据
  T get()->从ThreadLocal中获取数据
  void remove()-> 从当前ThreadLocal中移除指定数据
3.特点:
  a.ThreadLocal中获取的元素都是最后一次存进去的,一次只能存一个数据
  b.一个线程往TheadLocal中存的数据,其他线程获取不到
     在一条线程中使用的ThreadLocal中存储的对象,是同一个对象
4.作用:
  保证一条线程上使用的资源是同一个
5.ThreadLocal底层实质上是一个Map集合
  key:当前正在执行的线程对象->Thread.currentThread()
  value:随意->往ThreadLocal中存的数据
  
  这样,存数据的时候ThreadLocal底层直接将当前线程存的值和当前线程直接绑死,所以别的线程拿不到值
##### 如何获取JVM中的Class对象
（1）类型名.class
适用于任意数据类型

（2）对象.getClass()：获取对象的运行时类型
这个方法在java.lang.Object类中声明的。
只适用于引用数据类型，因为要有对象。

（3）Class.forName("类型的全名称")
类型的全名称：包.类名/接口名/枚举/注解

（4）类加载器对象.loadClass("类型的全名称")

获取系统默认类加载器的方式：ClassLoader.getSystemClassLoader()

#### 谈一谈你有哪些良好的编程习惯?
1. 比如 命名:严格按照驼峰式命名,尽量做到简明知意.
2. 比如 注释:注释表达清楚的前提下尽可能简洁,并且 单行注释独占一行, 尽量不写在代码后面
3. 比如 尽量不适用多层的for循环嵌套,或者if条件嵌套,提升代码的可读性
4. 比如 对于一些关键的名称,比如字段名称,尽量copy, 避免在单词拼写上犯错误浪费时间
5. 比如 编程中遇到问题, 首先将问题记录下来, 并用最快的时间去解决问题, 在业余时间再对遇到的问题进行详细的系统学习, 这样可以提高工作效率.

详细看: [阿里Java开发手册](../资料书/阿里Java开发手册.pdf)



1 基本数据类型 java 2大类数据类型：基本数据类型、引用数据类

数据结构：数组、链表、哈希表、栈、队列、树 （特点）

2 数组、字符串、集合等这些底层原理 arraylist linkedlist **hashmap** hashtable **concurrentHashMap**

两个集合的对比

3 多线程：如何创建线程(4种)、线程生命周期、线程的状态

4 网络编程：tcp和udp概念、3次握手、4次挥手

5 jdbc 连接步骤 具体连接步骤

**6 mysql ：多表连接查询、分组、排序**

#### JavaWeb
1 web域对象 作用域范围，1~2两个方法

2 cookie session

3 servlet filter listener **运行原理**

4 **http协议** 跨域 cookie是否可以跨域

请求头 ：包含什么内容

请求体：包含什么内容

REST风格的请求是怎么实现的?
	HiddenHttpMethodFilter过滤器
		-   作用:可以将**POST**请求转换为**PUT或DELETE**请求。
		-   使用HiddenHttpMethodFilter步骤
		-   注册HiddenHttpMethodFilter过滤器[web.xml]
		-   表单提交
			-   提交方式必须是:POST
			-   提交参数必须包含:`_method`参数
			-   参数数值:PUT或DELETE[不区分大小写]

### 2. 掌握MySQL，包括编写SQL语句和优化SQL。

#### MySQL有哪些语句
DDL 数据库定义语言
DCL 数据库控制语言
DML 数据操纵语言 增删改
DQL 数据查询语言 查

#### MySql的约束有几种
- 主键约束 primary key
- 自增约束 auto_increment
- 非空约束 not null
- 唯一约束 unique
#### Sql关键字书写顺序和执行顺序
- 书写顺序:
	- select
	- from
	- where
	- group by
	- having
	- order by
	- limit 
- 执行顺序: 
	- from
	- where
	- group by
	- having
	- select
	- order by
	- limit

#### MySQL如何多表联查

#### MySQL聚合函数
1.作用:纵向操作数据
2.聚合函数:
  count(列名):统计表中有多少条数据
  sum(列名):针对指定列进行求和
  avg(列名):针对指定列求平均值
  max(列名):求指定列的最大值
  min(列名):求指定列的最小值
3.格式:
  select 聚合函数(列名) from 表名 where 条件


#### 简单说一下groupBy_concat函数

#### 数据库的三大范式:
- 第一范式: 确保每列保持原子性
- 第二范式: 确保表中的每行都能唯一区分
- 第三范式: 非主键字段不能相互依赖

#### MySQL有哪些约束,如何添加

#### 什么是事务
#### 事务的特性
#### 事务隔离级别， 以及存在的问题
- 读未提交 脏读, 不可重复读, 幻读
- 读已提交 解决了脏读, 存在不可重复读, 幻读
- 可重复读 解决了脏读和不可重复读, 存在幻读
- 串行化 解决了脏读,不可重复读,幻读
#### 事务的传播行为
![](image/Pasted%20image%2020230113175140.png)
参考连接： https://www.bilibili.com/read/cv17284954
#### 如何开启事务
#### MySQL5和MySQL8的区别
#### 什么是sql注入， 如何解决
#### 数据库连接四大对象
#### 你知道哪些数据库连接池
#### MySQL的并发量是多少?

#### MySQL逻辑架构?

#### MySQL的存储引擎?
#### SQL预热是什么？

#### MySQL如何建立索引

#### MySQL索引失效问题?
#### 如何优化SQL?
#### 慢查询日志是什么？如何开启？
#### MySQL日志分析工具
#### MySQL视图，是什么， 作用， 适用场景，语法
#### MySQL分片是什么
#### MySQL分库分表





#### 索引 ： hashmap 二叉树 AVL 红黑树 btree b + tree

btree b + tree 重要

引擎 ： 行锁 表锁 悲观锁 乐观锁

优化 ： explain :

mysql 索引 优化 ：9个点

主从复制：原理 binlog

分库分表：时机

### 3. 掌握SpringMVC、Spring、Mybatis框架，理解Spring IOC、AOP思想，Mybatis动态SQL。


**spring mvc 核心执行流程**

**spring ioc aop** **bean生命周期** 13小方法（refresh() ）

redis rabbitmq **elasticsearch dsl** springcloud

rabbitmq ：工作模式（5种）

docker git maven nginx jenkins （入职）

Spring如何管理事务的:
- 编程式事务
  - TransactionTemplate
  - TransactionManager
- 声明式事务 
	- 基于XML的: 在配置文件中开启声明式事务
	- 基于注解的: @Transactional : 底层是aop
- Spring什么情况下会导致事务失效
  [Spring事务失效问题](https://www.51cto.com/article/719361.html) 
	- 1、方法没有被public修饰
		  在开发过程中，如果@Transactional事务注解添加在不是public修饰的方法上，这个时候，Spring的事务就会失效。
	- 2、类没有被Spring托管
		  如果事务方法所在的类没有加载到Spring IoC容器中，也就是说，事务方法所在的类没有被Spring管理，从而导致Spring无法实现代理，所以，Spring事务也会失效。
	- 3、不正确的异常捕获
		  如果事务方法抛出异常被 catch 处理了，导致 @Transactional 无法回滚而导致事务失效。
	- 4、同一类中方法调用
		  如果同一个类中的两个方法分别为A和B，方法A上没有添加事务注解，方法B上添加了 @Transactional事务注解，方法A调用方法B，那么，方法B的事务会失效。
	- 5、propagation事务传播行为配置错误
		  如果内部方法的事务传播类型为不支持事务的传播类型，那么，内部方法的事务在Spring中会失效。
	- 6、rollbackFor参数设置错误
		  如果在@Transactional注解中rollbackFor参数标注了错误的异常类型，那么，Spring事务的回滚就无法识别，导致事务回滚失效。
	- 7、没有配置事务管理器
		  即使在代码中使用了Spring的事务管理的功能，但是在项目中，如果没有配置Spring的事务管理器(@EnableTransactionManagement)，Spring的事务也不会生效。
	- 8、数据库本身不支持事务
		  Spring事务生效的前提是所连接的数据库要支持事务，如果底层的数据库都不支持事务，那么，Spring的事务肯定会失效。例如，如果使用的数据库为MySQL，并且选用了`MyISAM`存储引擎，则Spring的事务就会失效。

- 事务的传播行为
	* `propagation_required`
	当前存在事务时，支持当前事务，否则新建一个事务
	* `propagation_supports`
	当前存在事务时，支持当前事务，否则以非事务方式执行
	* `propagation_mandatory`
	当前存在事务时，支持当前事务，否则抛出异常
	* `propagation_required_new`
	总是新建一个事务，并且挂起当前事务
	* `propagation_not_supported`
	以非事务方式执行，挂起当前事务
	* `propagation_never`
	以非事务方式执行，如果当前存在事务，则抛出异常
	* `propagation_nested`
	如果当前存在事务，则在嵌套事务内执行，如果当前没有事务，则新建一个事务

拦截器与过滤器区别
 -   过滤器属于web组件,拦截器属于框架[SpringMVC,Mybatis等]
 -   过滤器作用:过滤Servlet,拦截器作用:拦截Controller
 -   过滤器存在两个触发点[执行时机],拦截器存在三个触发点[执行时机]
   ![](image/Pasted%20image%2020230207024642.png)

拦截器的实现方法
 -   实现步骤
 -   实现接口
 -   重写三个方法
	- preHandle
	- postHandle
	- afterCompletion




### 4. 熟练使用SpringBoot+SpringCloud进行微服务开发，包括Nacos、Sentinel、Openfeign、Gateway等组件。

### 5. 熟练使用消息中间件RabbitMQ，包括消息模型，消息确认机制，持久化，以及能够解决分布式事务问题。

### 6. 掌握Redis，包括数据类型、持久化机制、Redis主从和集群、使用Redis和Redisson实现分布式锁以及布隆过滤器。

#### redis 的内存淘汰策略（驱逐策略）(8种)？
内存满了
1. 不驱逐，直接抛异常
2. 最短时间者驱逐（ttl剩余最小）
3. 设置了ttl的key中随机驱逐一个
4. 所有key中随机驱逐一个
5. 设置了ttl的key中丢弃最近最少使用者驱逐
6. 所有key中最近最少使用者驱逐
7. 设置了ttl的key中使用频率最小的驱逐
8. 所有的key中使用过频率最少的驱逐
参考链接：http://cd.itheima.com/news/20220801/181457.html


### 7. 掌握nginx负载均衡、反向代理及常用配置。

### 8. 掌握创建和配置线程池，并熟练使用。

#### 线程池的拒绝策略（4种）？
阻塞队列已经满了，然后已开线程数达到最大线程数，则触发拒绝策略
1. 直接抛异常（默认）
2. 直接抛弃不处理
3. 将阻塞队列中的第一个弹出去（等待最久的抛弃），新来的排到最后
4. 哪个线程来请求，就让这个线程去处理（谁让我做事，我就让他自己做）
参考链接：http://t.csdn.cn/3rOG5

### 9. 熟练使用IntelliJ IDEA、Maven、Git等开发管理工具。

### 10. 熟悉七牛云OSS、阿里云OSS、Minio等云存储方案。

### 11. 熟悉Linux操作系统及常用命令以及docker常用命令。
lilux文件目录
/bin
存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；
/etc
存放系统管理和配置文件；
/home
存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；
/usr
用于存放系统应用程序；
/opt
额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat等都安装到这里；
/proc
虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；
/root
超级用户（系统管理员）的主目录（特权阶级）；
/sbin
存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；
/dev
用于存放设备文件；
/mnt
系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；
/boot
存放用于系统引导时使用的各种文件；
/lib
存放着和系统运行相关的库文件 ；
/tmp
用于存放各种临时文件，是公用的临时文件存储点；
/var
用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；
/lost+found
这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里
### 12. 了解ES和Kibana，包括ik分词器。

### 13. 了解JVM，包括其内存结构、垃圾回收算法、OOM问题排查和优化。
1. 请谈谈你对JVM 的理解？java8 的虚拟机有什么更新？

2.  什么是OOM ？什么是StackOverflowError？有哪些方法分析？
    
3.  JVM 的常用参数调优你知道哪些？
    
4.  内存快照抓取和MAT分析DUMP文件知道吗？
    
5.  谈谈JVM中，对类加载器你的认识？
    
6.  什么双亲委派机制
    
7.  JVM内存模型以及分区，需要详细到每个区放什么
    
8.  堆里面的分区：Eden，survival from to，老年代，各自的特点。
    
9.  GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方 10.Minor GC与Full GC分别在什么时候发生
    


### 14. 了解JUC 并发编程，包括创建和使用线程、线程生命周期以及安全容器、原子类和锁机制。


并发容器 lock 锁 线程池 线程特性 cas aqs




#### 什么是云原生？
 简单来说， 就是为了云而创造出来的技术。这些技术在云上运行更能发挥他们的优势。比如微服务框架Spring，SpringCloud组件等。
参考文献： https://zhuanlan.zhihu.com/p/150190166


#### 如何解决库存超卖问题？
加锁  synchronized
可以使用redis乐观锁提高效率，但是会出现库存遗留问题，
库存遗留问题可以用 lua脚本解决

#### lua脚本+redis解决库存遗留问题的原理？
redis+lua脚本解决库存遗留问题，实际上是利用了redis的单线程特性，使用了一个任务队列，将请求放到队列中，一个一个进行处理，也就是串行化了，避免了锁的争抢，而redis是基于内存的采用单线程+io多路复用技术，所以效率并不会降低.


#### RESTFull风格的请求有四种方式，但是浏览器一半只支持get和post，那么前端是怎么发起put和delete请求的？
前端请求的时候action用的是post,然后用到了隐藏的input标签，
`<input type="hidden" name="_method" value="put"/>`
name="`_method`", value="put"或者value="delete",
在后端有一个HiddenHttpMethodFilter过滤器，它将post请求转换成了put请求或者delete请求。在dofilterInternal方法中,获取到HttpServeletRequest对象,就是request对象，先判断请求方式为POST，并且获取过程没报错，这两个条件都满足后， 然后从request对象中获取"`_method`" 请求参数的值，先将它的值先转换成大写，用一个String类型的method来接收，(有一个常量List对象，这个对象中存储的两个值，一个是PUT,一个是DELETE)  然后判断method是不是被包含在这个常量List中，在的话就创建一个HttpServletRequestWrapper将原来的请求封装成method方式的请求，最后放行封装后的请求。

#### 线程安全问题是什么，如何解决 
当多个线程使用共享数据时，就会有线程安全问题。 
可以加同步 synchronized 解决。 
同步代码块或同步方法。 
同步代码块：手动选择同步锁对象。 
同步方法：静态方法的同步锁对象是当前类的Class 对象，
非静态方法的同步锁对象 是 this 对象


#### IO 流的四个抽象基类是什么
InputStream：字节输入流

OutputStream：字节输出流 
Reader: 字符输出流
 Writer：字符输出流

#### 如何实现对象序列化？ 
对象序列化需要用 ObjectOutputStream 的 writeObject 方法，对象的反序列化需 要用 ObjectInputStream 的 readObject 方法。 对象的类型需要实现java.io.Serializable 接口，并加序列化版本ID 
加 transient 和 static 修饰的成员变量都不序列化

#### Class 类对象如何获取？
对象.getClass（）
类名.Class
Class.forName(全类名)
类加载器对象.loadClass(全类名)

#### 反射的作用？
实现 Java 语言的动态性。 
在运行时动态获取类信息，动态创建对象，动态操作属性，动态调用方法。


#### 什么是函数式接口？
只有一个抽象方法的接口，即 SAM 接口（Single Abstract Inteface）

#### 什么是 Lambda 表达式？
Lambda 表达式是一种实现函数式接口的新语法, 代替了匿名内部类的实现方式， jdk1.8引入的

#### 什么是方法引用？
方法引用是java8中特定情况下简化lambada表达式的一种语法糖，这里的特定情况是指`当调用现有的方法时`可以用方法引用替代lambada表达式，其他情况下，则不可以替代。
详情链接： http://t.csdn.cn/Nh3Jd

#### 举几个函数式接口的例子
java.lang.Runnable 
java.util.Comparator 
java.util.function.Consumer 
java.util.function.Predicate 
java.util.function.Supplier 
java.util.function.Function


#### Comparable 和 Comparator 的区别 
Comparable：自然比较接口 
Comparator：定制比较接口


#### Iterable 和 Iterator 的区别
Iterable：可迭代接口，实现它的集合就可以支持 foreach 循环遍历 
Iterator：迭代器接口

#### sleep() 和 wait() 有什么区别? 
sleep 和 wait 都会导致当前线程进入阻塞状态，被挂起。 
sleep 不释放锁，睡眠时间到自动醒来，回到就绪状态 
wait 是会释放锁，要通过 notify()或 notifyAll()唤醒，回到就绪状态 
sleep 是在 Thread 类中声明的一个静态方法，Thread.sleep(毫秒) 
wait 是在Object 类中声明的非静态的方法，必须锁对象调用

#### 线程的生命周期？
创建 就绪 运行 阻塞 死亡


#### 请列出一些常用的类、接口、包，各至少 5 个 注意答案不固定 
常用类：String，Math，ArrayList，HashMap，System,Arrays，LocalDate，Thread，HashSet，LinkedList 等 
常用接口：Comparable，Comparator，Runnable，Serializable，Collection， Map,List,Set,Iterator，Consumer，Predicate 等 
常用包：java.lang， java.util，java.io，java.net，java.text，java.lang.reflect，java.time，java.util.function，java.math 等



#### 你知道哪些锁，分别介绍一下？




### 项目面试
#### Sku和SPU的区别：
SPU: 标准化产品单元
SKU: 库存量最小单位(最小库存单元)
参考乱接: http://t.csdn.cn/FnIAr
sku是商品的规格和属性，SPU是指商品编码
SKU=stock keeping unit(库存量单位)，主要是用来定价和管理库存。SKU即库存进出计量的单位，可以是以件、盒托盘等为单位。SKU是物理上不可分割的最小存货单元。
SPU = Standard Product Unit (标准化产品单元)，是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了商品的特性。


#### 项目中用redis mysql rabbitmq中间件 用在了什么地方 怎么用的 为啥这么用 

#### redis中存储key是怎么命名的？


#### 1、介绍下最近做的项目

可以从2个方向出发

介绍项目背景、项目功能和自己负责的功能模块

介绍项目背景、项目使用技术栈和自己负责的功能模块

##### 1.1 项目背景：

可以介绍项目是什么类型的（B2C、B2B2C、O2O这类），为什么要做这个项目，

有工作经验的找工作一般这样介绍：项目是自己公司开发，自己运营的，然后不断加功能进行迭代和维护；或者是项目定制的，给甲方客户开发的一个项目，上线后不负责维护和迭代，这样避免了很多后期问题，这两种都可以。

咱们可以借鉴以上的方式去介绍，刨除公司情况，以学习为主。

##### 1.2 项目功能：

结合项目，进行主要的功能模块阐述，可以结合电商项目的核心购物流程去说：后台管理系统（商品的管理）、商品详情、商品搜索、购物车、单点登录+社交登录、订单、支付、秒杀等等。

##### 1.3 技术栈：

使用springboot整合SpringCloud 以及MyBatis-Plus进行微服务构建，使用nacos作为注册中心和配置中心，使用feign进行服务远程调用，使用gateway网关进行请求负载、请求过滤、统一鉴权和限流，使用Sentinel进行服务的熔断和降级，使用Spring Cloud Sleuth进行链路追踪，针对于项目图片文件资源较多，采用FastDFS进行文件资源存储，使用redis数据库进行数据缓存以及分布式锁的实现，使用ElasticSearch进行商品的搜索业务实现…..（这块基础架构说完后，主要结合自己负责的功能模块去说技术点的应用）

##### 1.4 自己负责的功能模块：

       已简历为主，简历上写了哪几个，就说那几个，一定要知道自己简历写的什么内容。

##### 1.5 项目介绍参考：

尚品汇商城是B2C模式的综合性在线销售平台。商城分为后台管理部分与用户前台使用部分。后台管理部分包括：商品管理模块（商品分类、品牌、平台属性、SPU与SKU以及销售属性、商品上下架和商品评论管理等）、内容广告模块、库存管理模块、订单管理模块、促销管理（秒杀等商品设置）、客户模块、统计报表模块和系统基础权限等模块。

用户前台使用部分：商城首页、商品搜索（可按条件查询展示）、商品详情信息展示、购物车、用户单点登录和社交登录（微信登录）、用户会员中心、订单的创建修改、展示以及在线支付（支付宝、微信）、物流模块、商品评论以及秒杀活动等功能。

##### 1.6 项目架构图：

![](file:///C:/Users/damu/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)

##### 1.7 整体业务介绍：

首页

静态页面，包含了商品分类，搜索栏，商品广告位。

全文搜索

通过搜索栏填入的关键字进行搜索，并列表展示

分类查询

根据首页的商品类目进行查询

商品详情

商品的详细信息展示

购物车

将有购买意向的商品临时存放的地方

单点登录

用户统一登录的管理

结算

将购物车中勾选的商品初始化成要填写的订单

下单

填好的订单提交

支付服务

下单后，用户点击支付，负责对接第三方支付系统。

订单服务

负责确认订单是否付款成功，并对接仓储物流系统。

仓储物流

独立的管理系统，负责商品的库存。

后台管理

主要维护类目、商品、库存单元、广告位等信息。

秒杀

秒杀抢购完整方案

##### 1.8 后台管理系统功能：

电子商务网站整个系统的后端管理，按功能划分为九大模块，包括商品组织管理、订单处理、内容发布管理等模块。

###### 1.8.1 后台主页： 

各类主要信息的概要统计，包括客户信息、 订单信息、商品信息、库存信息、评论和最近反馈等。 

###### 1.8.2 商品模块： 

###### 1).商品管理：

商品SPU和SKU的添加、修改、 删除、复制、批处理、商品计划上下架、SEO、商品多媒体上传等，可以定义商品是实体还是虚拟，可以定义是否预订、是否缺货销售等。

###### 2).商品分类管理：

树形的商品目录组织管理，并可以设置品类关联与商品推荐。   

###### 3).商品平台属性管理：

定义商品的属性类型，设置自定义属性项。  

###### 4).品牌管理：

添加、修改、删除、上传品牌 LOGO。   

###### 5).商品评论管理：

商品评论的搜索、条件查询列表展示、回复、删除等功能。

###### 1.8.3 销售模块： 

###### 1).促销秒杀管理：

设置秒杀商品、购物车促销和 优惠券促销三类，可以随意定义不同的促销规则，满足日常促销活动：购物折扣、购物赠送积分、购物赠送优惠券、购物免运输费、特价商品、特定会员购买特定商品、折上折、买二送一等。  

###### 2).礼券、积分管理：

比如添加、发送礼券和积分 

###### 3).关联/推荐管理：

基于规则引擎，可以支持多种推荐类型，可手工添加或者自动评估商品。

###### 1.8.4 订单模块： 

###### 1).订单管理：

可以编辑、解锁、取消订单、 拆分订单、添加商品、移除商品、确认可备货等，也可对因促销规则发生变化引起的价格变化进行调整。订单处理完可发起退货、换货流程。 

###### 2).支付：

常用于订单支付信息的查看和手工 支付两种功能。手工支付订单，常用于“款到发货”类型的订单，可理解为对款到发货这类订单的一种补登行为。 

###### 3).结算：

提供商家与第三方物流公司的结算 功能，通常是月结。同时，结算功能也是常用来对“货到付款”这一类型订单支付后的数据进行对帐

###### 1.8.5 库存模块： 

###### 1).库存管理：

引入库存的概念，不包括销售规则为永远可售的商品，一个SKU对应一个库存量。库存管理提供增加、减少等调整库存量的功能;另外，也可对具体的SKU设置商品的保留数量、最小库存量、再进货数量。每条SKU商品的具体库存操作都会记录在库存明细记录里边。

###### 2).查看库存明细记录。 

###### 3).备货/发货：

创建备货单、打印备货单、打印发货单、打印快递单、完成发货等一系列物流配送的操作。 

###### 4).退/换货：

对退/换货的订单进行收货流程的处理。

###### 1.8.6 内容模块： 

###### 1).内容管理：

包括内容管理以及内容目录管理。内容目录由树形结构组织管理。类似于商品目录的树形结构，可设置目录是否为链接目录。   

###### 2).广告管理：

添加、修改、删除、上传广告、 定义广告有效时限。 

###### 3).可自由设置商城导航栏目以及栏目内容、栏目链接。

###### 1.8.7 客户模块： 

###### 1).客户管理：

添加、删除、修改、重设密码、 发送邮件等。   

###### 2).反馈管理：

删除、回复。 

###### 3).消息订阅管理：

添加、删除、修改消息组 和消息、分配消息组、查看订阅人。  

###### 4).会员资格：

添加、删除、修改。

###### 1.8.8 系统模块： 

###### 1).安全管6理：

管理员、角色权限分配和安全日志 

###### 2).系统属性管理：

用于管理自定义属性。可关联模块包括商品管理、商品目录管理、内容管理、客户管理。

###### 3).运输与区域：

运输公司、运输方式、运输 地区。  

###### 4).支付管理：

支付方式、支付历史。   

###### 5).包装管理：

添加、修改、删除。 

###### 6).数据导入管理：

商品目录导入、商品导入、 会员资料导入。   

###### 1.8.9 报表模块： 

   缺省数个统计报表，支持时间段过滤、支持按不同状态过滤、支持HTML、PDF和Excel格式的导出和打印。   

1.用户注册统计   2.低库存汇总   3.缺货订单   4.订单汇总   5.退换货

#### 2、项目开发周期：

**开发、维护和运营一体化的：**开发周期8个月左右，后期维护与迭代时间会更长

**项目定制：**前期架构+数据库设计+编码+开发+测试解bug共7个月左右进行项目交付

**培训学习项目:** 20天教程

#### 3、项目参与人数：

**一般公司:**项目经理（PM）1人、产品（PD）2人、界面设计（UI）2人、前端 3人、Java后台（DE）6人，其中1人是开发组长、测试（QA）2人、运维（SRE）1人

**培训学习项目：**根据课程内容编写代码，自己实现部分功能

#### 4、公司开发相关各岗位职责：

##### 4.1 项目经理（PM）：

企业建立以项目经理责任制为核心，对项目实行质量、安全、进度、成本管理的责任保证体系和全面提高项目管理水平设立的重要管理岗位。职责：                         

1、负责软件项目管理及计划实施；

2、具备较强管理、协调及沟通能力，帮助开发人员解决开发过程中遇到的技术问题，做好日常的开发团队管理工作；

3、与各团队协同工作，确保开发工作正常顺利的开展；

##### 4.2 产品（PD）：

企业中专门负责产品管理的职位，负责调查并根据用户的需求，确定开发何种产品，选择何种技术、商业模式等。并推动相应产品的开发组织，他还要根据产品的生命周期，协调研发、营销、运营等，确定和组织实施相应的产品策略，以及其他一系列相关的产品管理活动。职责：                                                1. 根据公司产品及用户需求，结合市场调研情况，进行产品规划；

2. 负责用户沟通、需求分析诊断；

3. 负责产品定位、用户体验流程定位及产品设计；

4. 推动、协调与控制产品策划及研发工作，保证产品需求的有效实现；

5. 负责产品持续升级，不断提升用户满意度及忠诚度；

6. 对行业及竞争产品的分析，跟踪最新发展趋势，并提交分析报告。

##### 4.3 界面设计（UI）：

对软件的人机交互、操作逻辑、界面美观的整体设计。职责：

1、负责公司产品PC端和移动端的UI界面设计工作；

2、配合完成校样修改和界面调整；

3、深入了解负责的产品，并通过各种设计形式和视觉语言让用户感受到产品的优点和特性；

4、跟进设计的变化和需求，注重相关文档的整理、资料的收集；能独立完成界面设计工作。

##### 4.4 开发组长（TL）：

其实就是个更小一点的项目经理。其职责：1、 参与软件的设计负责系统需求的分析，进行系统设计和数据库设计；

2、 解决开发过程中技术问题和提供解决办法；

3、 能够带领小组负责模块的功能开发；

4、 负责项目组代码的审查工作，有效地控制项目的质量风险。

##### 4.5 测试（QA）：

测试工程师，软件质量的把关者，工作起点高，发展空间大。职责：                                                                        1.理解、分析需求文档，挖掘、细化需求;

2.根据软件需求及设计文档编写测试用例，参与文档评审并维护相关文档;

3.准备测试数据，执行测试用例，记录测试结果，整理测试报告;

4.负责BUG的提交、跟踪、验证、关闭;

5.负责测试部门测试环境及BUG系统管理与维护。

6.对产品进行必要的功能，性能，安全，兼容性及其它方面的测试工作；

7.公司安排的其它工作。

##### 4.5 运维（SRE）：

运维工程师最基本的职责都是负责服务的稳定性。   

1. 产品发布前：负责参与并审核架构设计的合理性和可运维性，以确保在产品发布之后能高效稳定的运行。

2. 产品发布阶段：负责用自动化的技术或者平台确保产品可以高效的发布上线，之后可以快速稳定迭代。

3. 产品运行维护阶段：负责保障产品7*24H稳定运行，在此期间对出现的各种问题可以快速定位并解决；在日常工作中不断优化系统架构和部署的合理性，以提升系统服务的稳定性。

#### 5、项目开发流程:

##### 3.1 需求分析

![](file:///C:/Users/damu/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)

项目前期主要指的是项目业务需求调研、包括配合用户制定项目建设方案、技术规范书、配合市场人员进行售前技术交流等环节，此阶段应该组织由售前工程师、需求分析师以及系项目经理等组成一个临时小组，负责跟踪项目。这个小组根据项目的大小和客户的要求确定小组成员。

项目前期小组的工作是项目的开始，这个小组工作成绩的优劣、工作质量的高低，将直接影响项目的成败。因此，从管理层的角度，一定要重视这个环节。

项目前期小组需要完成的工作包括以下方面：

1、 客户的各种项目前期要求，如：方案介绍、业务需求编写等

2、 提交项目可行性分析报告，包括成本/效益分析

3、 提交项目建议方案

4、 提交业务需求说明书或需求分析说明书

##### 3.2 系统设计

![](file:///C:/Users/damu/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg)

系统设计是决定项目或软件系统“怎样做”的过程，这个过程回答了系统应该如何实现的问题。从软件工程的角度，设计阶段大约是整个项目开发成本的25%，所以，设计团队以及该团队的工作成绩对于整个系统来说至关重要。

人员需求

设计团队一般由3—8名设计人员组成，从这个阶段起，项目需要一名项目经理，行使项目组的各种管理职能。设计团队的成员具体包括：

1名项目经理

包括1—2名项目前期成员

1名系统构架师

1名数据库设计人员

1名用户界面设计人员组成

设计团队需要完成的工作包括：

1、项目开发计划

2、确定系统软硬件配置最佳方案

3、确定系统开发平台以及开发工具

4、确定系统软件结构

5、确定系统功能模块以及各个模块之间的关系

6、确定系统测试方案

7、提交系统数据库设计方案

8、提交系统概要设计文档

由于应用软件需求经常变化，因此设计需要考虑系统可扩展性，并需要在设计过程中对于重要的环节和用户进行及时沟通。

##### 3.3 编码开发

![](file:///C:/Users/damu/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg)

将用户的需求变成真正可用的软件系统，是通过编码和系统实现阶段来完成的。虽然软件的质量主要取决于系统设计的质量，但是编码的途径和实现的具体方法对程序的可靠性、可读性、可测试性和可维护性产生深远的影响。

人员需求

这个阶段要根据用户对项目进度的要求灵活组织开发团队。为了工作的连贯性，同时也为了解决在开发过程中用户需求有可能变化的因素，开发团队应该保留1—3名设计团队的成员。

人员分工

开发过程中，项目经理的角色非常重要，项目经理负责项目组开发人员的日常管理，控制项目的进度，负责和设计部门、市场部门以及客户之间进行必要的沟通。这个阶段通常是多个部门的人员共同组成一个项目组，因此，项目管理的一定要保证统一管理，理想状态是项目经理全权负责项目组人员的人员工作安排、业绩考核、工资奖金等，因为项目经理最了解项目组成员的工作态度和工作业绩。

一般在大型项目开发团队中，应该设立专门的技术经理岗位，负责对项目组的技术方案进行管控，技术经理最好是由设计团队中抽调出来。技术经理在项目开发过程中需要注意程序风格、编码规范等问题，并必须进行有效的代码管理（版本管理）。

开发过程还应该进行系统的单元测试工作，确保各个独立模块功能的正确性和性能满足需求说明书的要求。

开发团队应该完成的工作包括：

1、 系统的实现代码编写

2、 单元测试

3、 提交源代码清单

4、 提交单元测试报告

##### 3.4 系统测试

![](file:///C:/Users/damu/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg)

##### 3.5 部署实施

![](file:///C:/Users/damu/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg)

由于从事的应用软件的开发，因此，在开发完成之后经常会有系统集成、软件的安装等工作。这个阶段还经常伴随着新的业务需求和本地化需求的产生，因此将会有一部分的开发工作需要在这个阶段完成。

#### 6、项目版本控制：

    使用git进行版本控制，剩下的主要是对git仓库的一些列操作，要记住操作命令，以及分支切换等等。



#### 7、一般项目服务器数量：

#####  开发测试阶段：

       1. 开发在自己电脑上开发，代码提交到git仓库（gitlab、gitee等）的开发分支，到测试时，公司有1-2台测试服务器，把开发分支代码合并到测试分支，使用jenkins进行测试环境代码部署，测试人员进行测试。

#####  生产环境：

       1. 为了保证高可用，首先每个服务都要进行 集群部署，包括项目中依赖的第三方服务，这样的话，服务器的数量是很庞大的，以尚品汇商城所学功能实现为例，如下：

       1. Nginx2台（主备）；Nacos 3台（官方推荐最少3台）；项目中有服务数量*2（19*2=38）共需要38台；redis无中心化集群6台（3主3从），如果是主从哨兵集群5台；mysql数据库（读写分离的情况下，1主2从 4*3 =12）共12台；ES集群3台；rabbitmq集群2台；fastDFS集群（保证高可用情况下，traker2台，storage2组4台）共6台。

       1. 以上所述 服务器数量一共为72台，数量很多，以目前市场硬件服务器平均一台5万块钱来计算，72*5=360万，投入成本和维护成本很大，在项目前期没有大用户量的情况下，不建议。

       1. 针对于这个问题，如果是项目定制（外包）的话，可以由甲方（客户）自己去部署，这种情况也是存在的。

       1. 还有一种情况是在项目前期没有那么大的用户量情况下，可以采用单机（主备）部署方案，把所有服务部署同一台服务器上，进行资源节省。

#### 8、上线后QPS并发量，用户量、同时在线人数并发数等问题：

5. **一般情况下,****给客户定制的项目这些数据是拿不到的，项目给客户做的，甲方客户的运营数据是拿不到的。**

6. 但是要了解以下数据关键词：

7. （1）QPS（TPS）：每秒钟request/事务 数量

8. （2）并发数： 系统同时处理的request/事务数

9. （3）响应时间： 一般取平均响应时间

10. QPS（TPS）= 并发数/平均响应时间或者并发数 = QPS*平均响应时间 一个典型的上班签到系统，早上8点上班，7点半到8点的30分钟的时间里用户会登录签到系统进行签到。公司员工为1000人，平均每个员上登录签到系统的时长为5分钟。可以用下面的方法计算。 QPS = 1000/(30*60) 事务/秒 平均响应时间为 = 5*60 秒 并发数= QPS*平均响应时间 = 1000/(30*60) *(5*60)=166.7

11. 说明：

12. 一个系统吞吐量通常由QPS（TPS）、并发数两个因素决定，每套系统这两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统的吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换、内存等等其它消耗导致系统性能下降。

13. 我们做项目要排计划，可以多人同时并发做多项任务，也可以一个人或者多个人串行工作，始终会有一条关键路径，这条路径就是项目的工期。系统一次调用的响应时间跟项目计划一样，也有一条关键路径，这个关键路径是就是系统影响时间； 关键路径是有CPU运算、IO、外部系统响应等等组成。

14. 如果非要说，以下提供一套参数，但是仅供参考，可以根据自己设计适当调整：

15. 用户总量 几万+，日活 3000+，月活 12W+，一个月PV 30W+，并发量 500+

####  9、你们项目的微服务是怎么拆分的，拆分了多少？

17. 根据功能模块进行拆分，有多少功能模块就基本上拆出来多少个服务。

#### 10、如何解决并发问题的？

       1. 尚品汇商城是微服务架构构建，集群部署，数据库的分库分表读写分离，Redis缓存，RabbitMQ消息异步解耦，页面静态化等这些都是解决并发的手段。

19. 开发层面：微服务架构、缓存（Redis）、异步（MQ）、队排好（限流和削峰）

20. 部署层面：集群（高可用）和负载均衡----Nginx、Gateway、Feign

21. 硬件层面：CPU性能、硬盘（SSD）性能、内存大小

22. 网络层面：增加网络带宽、网络加速器

#### 11、如何保证接口的幂等性？

24. 根据状态机很多时候业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态。如果这些状态的值是有规律的，按照业务节点正好是从小到大，我们就能通过它来保证接口的幂等性。假如id=123的订单状态是已支付，现在要变成完成状态。update `order` set status=3 where id=123 and status=2;第一次请求时，该订单的状态是已支付，值是2，所以该update语句可以正常更新数据，sql执行结果的影响行数是1，订单状态变成了3。后面有相同的请求过来，再执行相同的sql时，由于订单状态变成了3，再用status=2作为条件，无法查询出需要更新的数据，所以最终sql执行结果的影响行数是0，即不会真正的更新数据。但为了保证接口幂等性，影响行数是0时，接口也可以直接返回成功。

25. 具体步骤：

26. 1 用户通过浏览器发起请求，服务端收集数据。

27. 2 根据id和当前状态作为条件，更新成下一个状态

28. 3 判断操作影响行数，如果影响了1行，说明当前操作成功，可以进行其他数据操作。

29. 4 如果影响了0行，说明是重复请求，直接返回成功。

30. 主要特别注意的是，该方案仅限于要更新的表有状态字段，并且刚好要更新状态字段的这种特殊情况，并非所有场景都适用。

31. 加分布式锁其实前面介绍过的加唯一索引或者加防重表，本质是使用了数据库的分布式锁，也属于分布式锁的一种。但由于数据库分布式锁的性能不太好，我们可以改用：redis或zookeeper。鉴于现在很多公司分布式配置中心改用apollo或nacos，已经很少用zookeeper了，我们以redis为例介绍分布式锁。目前主要有三种方式实现redis的分布式锁：

32. 1 setNx命令

33. 2 set命令

34. 3 Redission框架

35. 具体步骤：

36. 1 用户通过浏览器发起请求，服务端会收集数据，并且生成订单号code作为唯一业务字段。

37. 2 使用redis的set命令，将该订单code设置到redis中，同时设置超时时间。

38. 3 判断是否设置成功，如果设置成功，说明是第一次请求，则进行数据操作。

39. 4 如果设置失败，说明是重复请求，则直接返回成功。

40. 获取token

41. 除了上述方案之外，还有最后一种使用token的方案。该方案跟之前的所有方案都有点不一样，需要两次请求才能完成一次业务操作。

42. 第一次请求获取token

43. 第二次请求带着这个token，完成业务操作。

44. 具体步骤：

45. 1 用户访问页面时，浏览器自动发起获取token请求。

46. 2 服务端生成token，保存到redis中，然后返回给浏览器。

47. 3 用户通过浏览器发起请求时，携带该token。

48. 4 在redis中查询该token是否存在，如果不存在，说明是第一次请求，做则后续的数据操作。

49. 5 如果存在，说明是重复请求，则直接返回成功。

50. 6 在redis中token会在过期时间之后，被自动删除。

#### 12、你们项目中有没有用到什么设计模式？

52. 这个建议提前去了解几种常见的设计模式及其应用场景，将其套用到项目的某个场景中，以下提供几种常见的设计模式及其应用场景

53. 单例模式。

54. 单例模式是一种常用的软件设计模式。

55. 在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。

56. 应用场景：如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。

57. 工厂模式。

58. 工厂模式主要是为创建对象提供了接口。

59. 应用场景如下：

60. a、 在编码时不能预见需要创建哪种类的实例。

61. b、 系统不应依赖于产品类实例如何被创建、组合和表达的细节。

62. 策略模式。

63. 策略模式：定义了算法族，分别封装起来，让它们之间可以互相替换。此模式让算法的变化独立于使用算法的客户。

64. 应用场景如下。

65. a、 一件事情，有很多方案可以实现。

66. b、我可以在任何时候，决定采用哪一种实现。

67. c.、未来可能增加更多的方案。

68. d、 策略模式让方案的变化不会影响到使用方案的客户。

69. 举例业务场景如下。

70. 系统的操作都要有日志记录，通常会把日志记录在数据库里面，方便后续的管理，但是在记录日志到数据库的时候，可能会发生错误，比如暂时连不上数据库了，那就先记录在文件里面。日志写到数据库与文件中是两种算法，但调用方不关心，只负责写就是。

71. 观察者模式。

72. 观察者模式又被称作发布/订阅模式，定义了对象间一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

73. 应用场景如下：

74. a、对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。

75. b、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。

76. 迭代器模式。

77. 迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

78. 应用场景如下：

79. 当你需要访问一个聚集对象，而且不管这些对象是什么都需要遍 历的时候，就应该考虑用迭代器模式。其实stl容器就是很好的迭代器模式的例子。

80. 模板方法模式。

81. 模板方法模式定义一个操作中的算法的骨架，将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。

82. 应用场景如下：

83. 对于一些功能，在不同的对象身上展示不同的作用，但是功能的框架是一样的。

#### 13、生产环境出问题，你们是怎么排查的？

85. 生产环境出问题一般由多方面引起，可以由多方面进行排查，可以借鉴以下链接文章进行参考，面试的时候只需提出大概的思路即可：

86. https://blog.csdn.net/GitChat/article/details/79019454

#### 14、你做完这个项目后有什么收获？

88. 首先，在数据库方面，我现在是真正地体会到数据库的设计真的是一个程序或软件设计的重要和根基。因为数据库怎么设计，直接影响到一个程序或软件的功能的实现方法、性能和维护。由于我做的模块是要对数据库的数据进行计算和操作的，所以我对数据库的设计对程序的影响是深有体会，就是因为我们的数据库设计得不好，搞得我在对数据库中的数据进行获取和计算利润、总金时，非常困难，而且运行效率低，时间和空间的复杂也高，而且维护起来很困难，过了不久，即使自己有注释，但是也要认真地看自己的代码才能明白自己当初的想法和做法。加上师兄的解说，让我对数据库的重要的认识更深一层，数据库的设计真的是重中之重。

89. 其次，就是分工的问题。虽然这次的项目我们没有在四人选出一个组长，但是，由于我跟其他人都比较熟，也有他们的号码，然后我就像一个小组长一样，也是我对他们进行了分工。俗话也说，分工合作，分好了工，才能合作。但是这次项目，我们的分工却非常糟糕，我们在分工之前分好了模块，每个 责哪些模块。本以为我们的分工是明确的，后来才发现，我们的分工是那么的一踏糊涂，一些功能上紧密相连的模块分给了两个人来完成，使两个人都感到迷惘，不知道自己要做什么，因为两个人做的东西差不多。我做的，他也在做，那我是否要继续做下去？总是有这样的疑问。从而导致了重复工作，浪费时间和精力，并打击了队员的激情，因为自己辛辛苦苦写的代码，最后可能没有派上用场。我也知道，没有一点经验的我犯这样的错是在所难免，我也不过多地怪责自己，吸取这次的教训就好。分工也是一门学问。 再者，就是命名规范的问题。可能我们以前都是自己一个人在写代码，写的代码都是给自己看的，所以我们都没有注意到这个问题。就像师兄说的那样，我们的代码看上去很上难看很不舒服，也不知道我们的变量是什么类型的，也不知道是要来做什么的。但是我觉得我们这一组人的代码都写得比较好看，每个人的代码都有注释和分隔，就是没有一个统一的规范，每个人都人自己的一个命名规则和习惯，也不能见名知义。还有就是没有定义好一些公共的部分，使每个人都有一个自己的“公共部分”，从而在拼起来时，第一件事，就是改名字。而这些都应该是在项目一开始，还没开始写代码时应该做的。 然后，我自己在计算时，竟然太大意算错了利润，这不能只一句我不小心就敷衍过去，也是我的责任，而且这也是我们的项目的核心部分，以后在做完一个模块后，一定要测试多次，不能过于随便地用一个数据测试一下，能成功就算了，要用可能出现的所有情况去测试程序，让所有的代码都有运行过一次，确认无误。

90. 最后，也是我比较喜欢的东西，就是大家一起为了一个问题去讨论和去交流。因为我觉得，无论是谁，他能想的东西都是有限的，别人总会想到一些自己想不到的地方。跟他人讨论和交流能知道别人的想法、了解别人是怎样想一个问题的，对于同样的问题自己又是怎样想的，是别人的想法好，还是自己的想法好，好在什么地方。因为我发现问题的能力比较欠缺，所以我也总是喜欢别人问我问题，也喜欢跟别人去讨论一个问题，因为他们帮我发现了我自己没有发现的问题。在这次项目中，我跟植荣的讨论就最多了，很多时候都是不可开交的那种，不过我觉得他总是能够想到很多我想不到的东西，他想的东西也比我深入很多，虽然很多时候我们好像闹得很僵，但是我们还是很要好的! 嘻嘻！而且在以后的学习和做项目的过程中，我们遇到的问题可能会多很多，复杂很多，我们一个人也不能解决，或者是没有想法，但是懂得与他人讨论与交流就不怕这个问题，总有人的想法会给我们带来一片新天地。相信我能做得更好。 还有就是做项目时要抓准客户的要求，不要自以为是，自己觉得这样好，那样好就把客户的需求改变，项目就是项目，就要根据客户的要求来完成。

#### 15、在做这个项目的时候你碰到了哪些问题？你是怎么解决的？

（1）开发SpringBoot接口出现客户端和服务端不同步，导致接口无法测试，产生的原因沟通不畅。

（2）订单提交时由于本地bug或者意外故障导致用户钱支付了但是订单不成功，采用对账方式来解决。

（3）上线的时候一定要把支付的假接口换成真接口。

（4）项目中用到了曾经没有用过的技术，解决方式：用自己的私人时间主动学习

（5）在开发过程中与测试人员产生一些问题，本地环境ok但是测试环境有问题，环境的问题产生的，浏览器环境差异，服务器之间的差异

（6）系统运行环境问题，有些问题是在开发环境下OK，但是到了测试环境就问题，比如说系统文件路径问题、导出报表中的中文问题（报表采用POI），需要在系统jdk中添加相应的中文字体才能解决；



















