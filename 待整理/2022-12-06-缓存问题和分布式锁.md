- [ ] 使用redis 解决分布式锁
- [ ] 使用redisson 解决分布式锁
- [ ] 分布式锁+AOP缓存
- [ ] 实现动态代理两种方式:JDK 必须有接口; cglib 不能用final修饰 #动态代理
- [ ] 手写注解  元注解
- [ ] 怎么转换对象的格式, 用JSON字符串, 任何类型对象都可以转换成JSON串
- [ ] 类型转换出现的问题
- [ ] 尝试获取锁, 判断是否获取到了锁, 获取到了就查询,返回, 没获取到就休眠10毫秒, 自旋
- [ ] 布隆过滤器->解决缓存穿透 #布隆过滤器
- [ ] 如何定义注解: #注解
- [ ] AOP切面的编写
- [ ] 切点扫描注解的规则
- [ ] 



跨JVM的互斥机制来控制共享资源的访问



Zipkin 链路追踪 端口9411 #Zipkin


[什么是动态代理?两种常用的动态代理方式 (itcast.cn)](https://www.itcast.cn/news/20200717/12001737842.shtml)

[Spring AOP（通知、连接点、切点、切面） - sandea - 博客园 (cnblogs.com)](https://www.cnblogs.com/sandea/p/11175834.html)


#缓存
## 缓存问题: 
1. 缓存穿透
2. 缓存雪崩
3. 缓存击穿

### 1. 缓存穿透
	问题1 : 访问一个MySQL数据库中不存在值的数据, 首先在缓存中查寻, 没有结果, 会查MySQL数据库,得到结果必然是null, 没有要进行缓存的数据. 如果有大量这样的请求过来, 就会导致大量请求访问数据库导致MySQL数据库压力过大而崩溃. 
	解决办法: 如果缓存中没有查到, 就需要查询MySQL数据库, 数据库中如果查出来是null, 就手动new 一个对象来进行缓存, 其它请求过来时就能在缓存中得到结果
	问题2 : 如果有人恶意生成大量不存在值的key进行查询, 还是缓存中得不到结果, 这时大量请求又穿过了缓存,到达了MySQL数据库查询
	解决办法: 布隆过滤器
	
	布隆过滤器
	1970年, 一个叫布隆的小伙子提出的 
	布隆过滤器就是一个bit数组, 默认每个值都是0 , 在插入数据时, 将一个key值进行多次hash运算得到多个hash值, 然后把bit数组对应的多个位置改为1, 来标记该请求时存在的, 在查询数据时, 就可以根据判断查询的数据是否存在, 如果存在就放行, 如果不存在则进行处理 , 可以防止有人恶意访问大量数据库中不存在的值导致的缓存穿透问题 . 优点是查询快, 占用存储空间也小; 缺点是删除困难和存在误判(hash冲突导致),可能不存在的数据经过hash运算与之前存过的数据得到相同hash值, 被认为是存在, 然后就会放行 ,但是可以手动指定误差率. 布隆这时可能会说一句: 抛开其它不谈, 你就说快不快吧 !


### 2. 缓存雪崩
	问题: 如果多个缓存的key值设置了相同的过期时间, 在某一时刻大量请求过来时, 刚好有大量的缓存过期, 导致大量请求访问MySQL数据库
	解决办法: 给每个key设置的过期时间加上一个1~5分钟的随机值, 不要让他们同时过期

### 3. 缓存击穿
	问题: 某个超高热点key, 在某一时刻失效, 导致大量请求落到MySQL数据库, 导致数据库压力过大
	解决办法: 加锁, 缓存中没有得到数据, 再访问数据库之前先争夺锁, 只能有一个请求得到锁, 其它请求休眠一会然后自旋(重新查询缓存), 得到锁的请求去数据库中查询, 然后把数据放入缓存


锁的类型: 
	独占锁 sychronized 和 lock
	共享锁 读写锁中的读锁

#分布式锁
分布式锁的实现方式: 
1. 基于数据库实现分布式锁
   在数据库中有三个字段: 方法名, 线程名, 线程获取次数, 给方法名字段添加唯一约束, 保存失败则返回false , 保存成功则返回true 获取到锁 ,  删除该记录即释放锁, 同一线程再次调用(可重入锁), 会给线程获取次数+1, 释放一次则-1, 直到减为0 则删除
   ![](image/Pasted%20image%2020221208002727.png)
2. 基于redis实现分布式锁->性能最高
      思想: 占坑思想
   setnx 或者 set(前提: 高版本redis) 如果key存在则添加失败, 返回0 , 不存在则添加成功, 返回1 得到锁
   释放锁需要保证原子性: 可以用lua脚本
3. 基于zookeeper实现分布式锁->可靠性最高: 强一致性
   zookeeper有一个持久化锁节点, 请求连接zookeeper时, 会生成带有编号和监听器的的临时节点, 只有编号在第一位的节点获取到锁, 其它每个临时节点监听上一个编号的节点, 当第一个请求处理完后, 断开连接, 对应编号的临时节点也随之消失, 锁释放, 监听这个节点的那个节点监听到它消失, 马上上位 成为编号在第一位的节点, 获取到锁
   ![](image/Pasted%20image%2020221208002058.png)
   


## 上课走神的地方: 
![](image/Pasted%20image%2020221206090931.png)


@SneakyThrows 注解: 鬼鬼祟祟的抛出  #SneakyThrows
是将编译时异常封装成运行时异常骗过编译器, 在运行阶段抛出
![](image/Pasted%20image%2020221206093029.png)